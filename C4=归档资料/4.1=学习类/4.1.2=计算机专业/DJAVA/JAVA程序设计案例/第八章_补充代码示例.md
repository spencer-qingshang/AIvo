# 第八章：集合框架 - 补充代码示例

---

### 1. `List` 和 `ArrayList` 示例 (有序、可重复)

`List` 的主要特点是可以通过索引精确控制元素。`ArrayList` 是其最常用的实现。

```java
import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        // 创建一个只能存放字符串的List
        List<String> fruits = new ArrayList<>();
        
        // 1. 添加元素 (add)
        fruits.add("苹果");
        fruits.add("香蕉");
        fruits.add("苹果"); // List允许重复
        System.out.println("原始列表: " + fruits); // 输出: [苹果, 香蕉, 苹果]
        
        // 2. 按索引获取元素 (get)
        String firstFruit = fruits.get(0);
        System.out.println("第一个水果是: " + firstFruit); // 输出: 苹果
        
        // 3. 按索引修改元素 (set)
        fruits.set(1, "橙子");
        System.out.println("修改后列表: " + fruits); // 输出: [苹果, 橙子, 苹果]
        
        // 4. 获取大小 (size)
        System.out.println("列表中的水果数量: " + fruits.size()); // 输出: 3
        
        // 5. 遍历 (foreach)
        System.out.println("--- 遍历所有水果 ---");
        for(String fruit : fruits) {
            System.out.println(fruit);
        }
    }
}
```

---

### 2. `Set` 和 `HashSet` 示例 (无序、不可重复)

`Set` 的核心用途是去重。`HashSet` 是其最常用的实现，不保证存入和取出的顺序一致。

```java
import java.util.HashSet;
import java.util.Set;

public class SetExample {
    public static void main(String[] args) {
        // 创建一个只能存放整数的Set
        Set<Integer> numbers = new HashSet<>();
        
        // 1. 添加元素 (add)
        numbers.add(100);
        numbers.add(200);
        boolean isAdded = numbers.add(100); // 尝试添加重复元素
        
        System.out.println("Set中的元素: " + numbers); // 输出: [100, 200] (顺序可能不同)
        System.out.println("重复的100是否被添加: " + isAdded); // 输出: false
        
        // 2. 判断是否包含元素 (contains)
        boolean has200 = numbers.contains(200);
        System.out.println("Set中是否包含200: " + has200); // 输出: true
        
        // 3. 删除元素 (remove)
        numbers.remove(100);
        System.out.println("删除100后的Set: " + numbers); // 输出: [200]
    }
}
```

---

### 3. `Map` 和 `HashMap` 示例 (键值对存储)

`Map` 用于存储键值对，通过唯一的键（Key）来查找对应的值（Value）。`HashMap` 是其最常用的实现。

```java
import java.util.HashMap;
import java.util.Map;

public class MapExample {
    public static void main(String[] args) {
        // 创建一个Map，键是学生姓名(String)，值是分数(Integer)
        Map<String, Integer> scores = new HashMap<>();
        
        // 1. 添加键值对 (put)
        scores.put("张三", 95);
        scores.put("李四", 88);
        scores.put("张三", 100); // 键"张三"已存在，新值100会覆盖旧值95
        
        System.out.println("原始Map: " + scores); // 输出: {李四=88, 张三=100} (顺序可能不同)
        
        // 2. 根据键获取值 (get)
        Integer zhangSanScore = scores.get("张三");
        System.out.println("张三的分数: " + zhangSanScore); // 输出: 100
        
        // 3. 判断键是否存在 (containsKey)
        boolean hasWangWu = scores.containsKey("王五");
        System.out.println("是否包含王五的成绩: " + hasWangWu); // 输出: false
        
        // 4. 遍历Map (推荐使用entrySet)
        System.out.println("--- 遍历所有成绩 ---");
        for (Map.Entry<String, Integer> entry : scores.entrySet()) {
            String name = entry.getKey();
            Integer score = entry.getValue();
            System.out.println(name + " -> " + score);
        }
    }
}
```

---

### 4. `Collections` 工具类示例

`Collections` 类提供了大量静态方法来操作集合，非常实用。

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class CollectionsExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>();
        numbers.add(30);
        numbers.add(10);
        numbers.add(50);
        numbers.add(20);
        
        System.out.println("原始列表: " + numbers);
        
        // 1. 排序 (sort) - 默认升序
        Collections.sort(numbers);
        System.out.println("排序后: " + numbers); // 输出: [10, 20, 30, 50]
        
        // 2. 打乱顺序 (shuffle)
        Collections.shuffle(numbers);
        System.out.println("打乱后: " + numbers); // 每次输出结果可能都不同
        
        // 3. 反转顺序 (reverse)
        // 先排序再反转，实现降序
        Collections.sort(numbers); 
        Collections.reverse(numbers);
        System.out.println("反转后(实现降序): " + numbers); // 输出: [50, 30, 20, 10]
        
        // 4. 查找最大/最小值 (max/min)
        Integer max = Collections.max(numbers);
        Integer min = Collections.min(numbers);
        System.out.println("最大值: " + max); // 输出: 50
        System.out.println("最小值: " + min); // 输出: 10
    }
}
```

---

### 5. `Comparable` vs `Comparator` 示例

这两个接口都用于排序，是 `Collections.sort()` 方法的核心。

#### `Comparable` 示例 (内部比较器)

让 `Student` 类自己拥有“默认”的比较能力（例如按年龄排序）。

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

// 让Student类实现Comparable接口，定义默认按年龄升序排序
class Student implements Comparable<Student> {
    String name;
    int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" + "name='" + name + "'" + ", age=" + age + '}' ;
    }
    
    // 实现compareTo方法
    @Override
    public int compareTo(Student other) {
        // this.age - other.age 是升序
        // other.age - this.age 是降序
        return this.age - other.age;
    }
}

public class ComparableExample {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("张三", 20));
        students.add(new Student("李四", 18));
        students.add(new Student("王五", 22));

        System.out.println("排序前: " + students);
        
        // 直接调用sort，它会自动使用Student类内部的compareTo方法
        Collections.sort(students); 
        
        System.out.println("按年龄升序排序后: " + students);
    }
}
```

#### `Comparator` 示例 (外部比较器)

当 `Student` 类没有实现 `Comparable`，或者我们想临时换一种排序规则（例如按名字长度排序）时使用。

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

// 假设这里的Student类没有实现Comparable
// class Student { ... } 

// 创建一个独立的比较器类，按学生姓名的长度排序
class SortByNameLength implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return s1.name.length() - s2.name.length();
    }
}

public class ComparatorExample {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("Lisi", 18)); // 4个字符
        students.add(new Student("Wangwu", 22)); // 6个字符
        students.add(new Student("San", 20)); // 3个字符

        System.out.println("排序前: " + students);
        
        // 调用sort的重载方法，传入我们自定义的比较器
        Collections.sort(students, new SortByNameLength()); 
        
        System.out.println("按姓名长度升序排序后: " + students);
    }
}
```

```