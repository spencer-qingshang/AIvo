# 1. 集合框架

## 识记：

### 集合框架体系；

Java 集合框架主要封装在 

### 接口之间相互关系。

- **Collection**: 集合层次结构的根接口（它是 Iterable 的子接口）。

- **List**: 有序、可重复的集合。

- **Set**: 无序、不可重复的集合。

- **实现类 (如 ArrayList)**: 实现了接口中定义的方法，包含了具体的数据结构逻辑。

# 2. Collection接口

## 识记：

### Collection接口常用方法。

| 操作类型 | 方法名 | 描述 | 
| -- | -- | -- |
| 添加 | boolean add(E e) | 添加元素 | 
|   | boolean addAll(Collection<? extends E> c) | 添加另一个集合的所有元素 | 
| 删除 | boolean remove(Object o) | 删除指定元素（只删第一个匹配的） | 
|   | void clear() | 清空集合 | 
| 判断 | boolean contains(Object o) | 判断是否包含某元素 (依赖 equals 方法) | 
|   | boolean isEmpty() | 判断集合是否为空 | 
| 获取 | int size() | 获取元素个数 | 
| 转换 | Object[] toArray() | 转为数组 | 


# 3. List

## 识记：

### List接口集合作用；List与ArrayList关系；泛型、Iterator接口、foreach及应用场景。

#### 1. List 接口的作用与特点

- **特点**: **有序**（存取顺序一致，有索引）、**可重复**（允许存储相同的元素）。

- **作用**: 用于存储线性数据序列，精确控制每个元素的插入位置，并通过索引访问元素。

#### 2. List 与 ArrayList 的关系

- **List**: 是**接口**，定义了规范（标准）。

- **ArrayList**: 是 List 接口最常用的**实现类**。**底层原理**: 基于**动态数组**。**性能特点**: **查询快**（通过索引直接定位），**增删慢**（涉及数组扩容和元素位移）。

#### 3. 泛型 (Generics) <T>

- **作用**: 在编译阶段约束集合中存储的数据类型。

- **好处**:避免类型转换异常 (ClassCastException)。取出元素时无需强制类型转换。

- **示例**: List<String> list 只能存字符串。

#### 4. 遍历方式

- **Iterator (迭代器)**: 集合遍历的标准方式。

- **foreach (增强for循环)**: Iterator 的语法糖（底层也是迭代器），写法更简洁。

## 领会：

### 能够定义List集合变量并进行增删改等操作，能够通过Iterator接口和foreach对集合进行遍历访问。

```java
1. 定义 List 集合变量
// 推荐使用多态写法：接口引用指向实现类对象
List<String> list = new ArrayList<>();

2. 常用操作 (List 特有的索引操作)
list.add("Java");           // 增
list.add(1, "Python");      // 在指定索引插入
String s = list.get(0);     // 查：获取指定索引元素
list.set(1, "C++");         // 改：修改指定索引元素
list.remove(1);             // 删：删除指定索引元素

3. 遍历访问 (重点)
方式一：Iterator 迭代器 (最基础)
Iterator<String> it = list.iterator();
while(it.hasNext()) {
    String s = it.next(); // 获取元素并移动指针
    // 注意：如果在遍历中需要删除元素，必须使用 it.remove()，不能用 list.remove()
    System.out.println(s);
}

方式二：foreach (最常用)
// 适用于只需要读取元素，不需要操作索引或删除元素的场景
for (String s : list) {
    System.out.println(s);
}

方式三：普通 for 循环 (利用索引)
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
}
```

## 应用：

### 能针对特定需求，利用List集合实现相关数据的存储与运算。

```java
场景：学生管理系统
需求: 存储学生姓名，去除重复名字（假设业务逻辑层处理），并输出所有学生。
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class StudentListDemo {
    public static void main(String[] args) {
        // 1. 利用 List 集合实现数据存储
        List<String> students = new ArrayList<>();
        
        // 2. 添加数据
        students.add("张三");
        students.add("李四");
        students.add("王五");
        students.add("张三"); // List 允许重复
        
        System.out.println("原始名单: " + students);

        // 3. 运算：例如删除名为 "王五" 的学生
        // 必须小心：在遍历中删除推荐用 Iterator
        Iterator<String> it = students.iterator();
        while(it.hasNext()){
            String name = it.next();
            if("王五".equals(name)){
                it.remove(); // 安全删除
            }
        }

        // 4. 运算：修改，将所有的 "张三" 改为 "张三丰"
        for(int i = 0; i < students.size(); i++){
            if("张三".equals(students.get(i))){
                students.set(i, "张三丰");
            }
        }

        // 5. 最终结果遍历
        System.out.println("--- 处理后的名单 ---");
        for (String s : students) {
            System.out.println(s);
        }
    }
}
```

# 4. Set

## 识记：

### Set作用，TreeSet、HashSet异同。

#### 1. Set 接口的作用

- **核心特点**: **无序**（不保证存取顺序）、**不可重复**（元素唯一）。

- **作用**:**去重**: 最主要的功能是用于过滤重复元素。**数学集合**: 模拟数学中的集合概念（互异性）。**注意**: Set 接口没有索引，所以**不能**使用 get(i) 方法，也不能使用普通 for 循环遍历。

#### 2. HashSet 与 TreeSet 的异同 (重点)

| 特性 | HashSet | TreeSet | 
| -- | -- | -- |
| 底层结构 | 哈希表 | 红黑树 | 
| 有序性 | 无序 | 排序 | 
| 性能 | 增删查性能极高 (O(1)) | 较慢 (O(log n))，因为要维护排序 | 
| Null值 | 允许存一个 null | 不允许 | 
| 去重依据 | hashCode() | compareTo() | 
| 应用场景 | 只需要去重，不在乎顺序 | 需要去重，且需要对结果进行排序 | 


## 领会：

### 能够使用HashSet定义集合，以及集合元素的修改与访问。

```java
1. 定义 HashSet 集合
// 多态写法
Set<String> set = new HashSet<>();

2. 元素的访问 (遍历)
由于没有索引，不能使用 set.get(index)。只能通过以下两种方式访问
方式一：foreach (增强for循环)
for (String s : set) {
    System.out.println(s);
}

方式二：Iterator 迭代器
Iterator<String> it = set.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}

3. 元素的修改
Set 没有提供直接修改元素的方法（如 set.set(index, value) 不存在）。
原因: Set 中的元素位置取决于元素本身（哈希值或排序值），修改元素值会导致其存储位置改变。
如何实现修改: “先删后加”。
// 需求：把集合中的 "Java" 修改为 "Java SE"
if (set.contains("Java")) {
    set.remove("Java");   // 1. 删除旧值
    set.add("Java SE");   // 2. 添加新值
}
```

## 应用：

### 能针对特定需求，利用Set集合实现相关数据的存储与运算，解决实际问题。

```java
场景一：数据去重
需求: 有一堆抽奖号码（可能重复），需要统计一共有多少个不同的号码。
import java.util.HashSet;
import java.util.Set;

public class SetDemo {
    public static void main(String[] args) {
        // 模拟原始数据 (包含重复项)
        int[] nums = {101, 102, 101, 103, 102, 104};

        // 1. 利用 Set 集合实现存储与去重
        Set<Integer> uniqueNums = new HashSet<>();
        
        // 2. 遍历数组添加到集合中
        for (int n : nums) {
            // Set.add() 方法：如果元素已存在，返回 false 并忽略，不会报错
            boolean isAdded = uniqueNums.add(n); 
            if(isAdded) {
                System.out.println("成功存入: " + n);
            } else {
                System.out.println("发现重复元素，丢弃: " + n);
            }
        }

        // 3. 结果
        System.out.println("去重后的号码: " + uniqueNums);
        System.out.println("独立号码数量: " + uniqueNums.size());
    }
}

场景二：交集运算 (进阶应用)
需求: 计算两个人的共同好友。
Set<String> userA = new HashSet<>();
userA.add("张三");
userA.add("李四");

Set<String> userB = new HashSet<>();
userB.add("李四");
userB.add("王五");

// 利用 retainAll 计算交集
userA.retainAll(userB); 
// 此时 userA 中只剩下共同的元素
System.out.println("共同好友: " + userA); // 输出: [李四]

```

# 5. Map接口

## 识记：

### Map集合概念及作用及主要方法。

#### 1. 概念与作用

- **双列集合**: Map 与 Collection 不同，Collection 是单列（存一个值），Map 是双列（存一对值）。

- **键值对 (Key-Value)**: 元素由 <K, V> 组成。**Key (键)**: **唯一**，不允许重复（类似身份证号）。**Value (值)**: 可以重复（类似姓名）。每个 Key 只能映射到一个 Value。

- **关系**: Map 接口**不继承** Collection 接口，它是独立的顶层接口。

#### 2. Map 常用方法 (熟记)

| 操作类型 | 方法声明 | 描述 | 
| -- | -- | -- |
| 添加/修改 | V put(K key, V value) | 如果键不存在，则添加； | 
| 删除 | V remove(Object key) | 根据键删除键值对，返回被删除的值。 | 
|   | void clear() | 清空所有键值对。 | 
| 查询 | V get(Object key) | 根据键获取值。如果键不存在返回  | 
| 判断 | boolean containsKey(Object key) | 判断集合是否包含指定的键（高效）。 | 
|   | boolean containsValue(Object value) | 判断集合是否包含指定的值（低效，需遍历）。 | 
|   | boolean isEmpty() | 判断是否为空。 | 
|   | int size() | 获取键值对的个数。 | 
| 视图获取 | Set<K> keySet() | 获取所有 | 
|   | Collection<V> values() | 获取所有 | 
|   | Set<Map.Entry<K,V>> entrySet() | 获取所有 | 


## 领会：

### 能使用HashMap定义集合变量并能够进行数据操作和遍历。

```java
1. 定义 Map 集合变量
HashMap: Map 接口最常用的实现类，底层基于哈希表。
特点: 无序（存取顺序不一致）、键不允许重复（重复则覆盖）、允许存储 null 键和 null 值。
// 泛型定义：Key是String类型，Value是Integer类型
Map<String, Integer> map = new HashMap<>();

2. 基本数据操作
// 1. 添加与修改
map.put("苹果", 5);
map.put("香蕉", 3);
map.put("苹果", 10); // Key "苹果" 已存在，将 Value 5 修改为 10

// 2. 获取
Integer count = map.get("香蕉"); // 返回 3
Integer nullVal = map.get("西瓜"); // 返回 null

// 3. 判断与删除
if (map.containsKey("苹果")) {
    map.remove("苹果"); // 删除键为 "苹果" 的数据
}

3. 集合遍历 (重点难点)
Map 不能直接用 foreach 遍历，需要先转为单列集合（keySet 或 entrySet）。
方式一：键找值 (KeySet) - 常用
思路：先拿到所有的 Key，再通过 get(key) 拿 Value。
Set<String> keys = map.keySet(); // 获取所有键
for (String key : keys) {
    Integer value = map.get(key); // 回查 value
    System.out.println(key + " = " + value);
}

方式二：键值对对象 (EntrySet) - 高效
思路：直接拿到 Entry 对象，它里面同时封装了 Key 和 Value。
// Entry 是 Map 内部定义的接口
Set<Map.Entry<String, Integer>> entries = map.entrySet();
for (Map.Entry<String, Integer> entry : entries) {
    String k = entry.getKey();
    Integer v = entry.getValue();
    System.out.println(k + " = " + v);
}

```

## 应用：

### 能根据特定场景要求，正确使用HashMap类定义集合遍历，按任务需求实现相关功能。

```java
场景：统计投票/字符出现次数
需求: 有一个字符串数组 String[] votes = {"A", "B", "A", "C", "A", "B"};，统计每个候选项出现的次数。
分析思路:
Map 的 Key 存候选项名字 (String)。
Map 的 Value 存出现的次数 (Integer)。
遍历数组，如果 Map 中没有该 Key，存入 1；如果已有，拿出旧值 +1 后存回去。

import java.util.HashMap;
import java.util.Map;

public class MapTest {
    public static void main(String[] args) {
        // 原始数据
        String[] votes = {"A", "B", "A", "C", "A", "B"};

        // 1. 定义 Map 存放统计结果
        Map<String, Integer> countMap = new HashMap<>();

        // 2. 遍历数据进行统计
        for (String vote : votes) {
            if (countMap.containsKey(vote)) {
                // 情况一：Map中包含该键 -> 次数 +1
                Integer count = countMap.get(vote);
                countMap.put(vote, count + 1);
            } else {
                // 情况二：Map中不包含该键 -> 第一次出现，记为 1
                countMap.put(vote, 1);
            }
        }

        // 3. 输出结果
        System.out.println("统计结果: " + countMap); 
        // 输出: {A=3, B=2, C=1} (顺序可能不同)
    }
}

```

# 6. Collections类

## 识记：

### Collections类的sort方法；Comparable、Comparator接口的作用。

#### 1. Collections 类

- **概念**: java.util.Collections 是一个操作集合的**工具类**。

- **注意**: 区分 **Collection**（接口，集合的顶层规范）与 **Collections**（类，提供静态方法）。

- **常用方法**:

- public static void sort(List<T> list): 对 List 集合进行升序排序（依赖元素的自然排序）。

- public static void sort(List<T> list, Comparator<? super T> c): 根据指定的比较器对 List 集合进行排序。

- shuffle(List<?> list): 打乱集合顺序。

- reverse(List<?> list): 反转集合顺序。

#### 2. 两个比较接口 (核心考点)

| 特性 | Comparable | Comparator | 
| -- | -- | -- |
| 位置 | java.lang | java.util | 
| 角色 | 内部 | 外部 | 
| 实现方式 | 元素类 | 定义一个单独的类或匿名内部类 | 
| 核心方法 | int compareTo(T o) | int compare(T o1, T o2) | 
| 场景 | 定义类的默认排序规则 (如 String, Integer) | 临时改变排序规则，或无法修改源码时使用 | 


## 领会：

### 能用Collections类的sort方法对集合进行排序，能够使用Comparable实现类的可排序，能用Comparator接口设计比较器。

```java
1. 使用 Comparable (自然排序)
要让集合中的元素（如 Student 对象）能被 Collections.sort(list) 直接排序，该类必须实现 Comparable 接口。

// 1. 让类实现 Comparable 接口
public class Student implements Comparable<Student> {
    private String name;
    private int age;

    // 省略构造器、getter/setter

    // 2. 重写 compareTo 方法
    @Override
    public int compareTo(Student other) {
        // 规则：this - other 是升序；other - this 是降序
        return this.age - other.age; // 按年龄升序排序
    }
}

// 调用：
Collections.sort(studentList);

2. 使用 Comparator (定制排序)
如果类没有实现 Comparable，或者你想临时换一种排序方式（比如改为按姓名长度排），使用 Comparator。
// 调用 sort 的重载方法，传入一个比较器对象
Collections.sort(studentList, new Comparator<Student>() {
    @Override
    public int compare(Student s1, Student s2) {
        // 比较逻辑：按年龄降序
        return s2.getAge() - s1.getAge();
    }
});

// Java 8 Lambda 写法 (更推荐，代码简洁)
Collections.sort(studentList, (s1, s2) -> s2.getAge() - s1.getAge());

```

## 应用：

### 能根据特定场景要求，正确使用Collections类、Comparable接口、Comparator接口对特定数据进行排序，完成实际任务。

```java
场景：复杂的商品排序
需求: 有一组商品，包含名称、价格、销量。排序规则:
优先按价格从低到高排序（升序）。
如果价格相同，则按销量从高到低排序（降序）。
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

// 定义简单商品类
class Product {
    String name;
    double price;
    int sales;

    public Product(String name, double price, int sales) {
        this.name = name;
        this.price = price;
        this.sales = sales;
    }
    
    @Override
    public String toString() {
        return "Product{name='" + name + "', price=" + price + ", sales=" + sales + "}";
    }
}

public class SortDemo {
    public static void main(String[] args) {
        List<Product> products = new ArrayList<>();
        products.add(new Product("小米手机", 1999, 5000));
        products.add(new Product("华为手机", 3999, 2000));
        products.add(new Product("OPPO手机", 1999, 8000)); // 价格同，销量高
        products.add(new Product("苹果手机", 5999, 1000));

        // 应用：使用 Comparator 实现多重条件排序
        Collections.sort(products, new Comparator<Product>() {
            @Override
            public int compare(Product p1, Product p2) {
                // 1. 先比较价格 (double类型建议用 Double.compare)
                // 如果 p1 < p2 返回负数 (升序)
                int priceResult = Double.compare(p1.price, p2.price);
                
                // 2. 如果价格不相等，直接返回价格比较结果
                if (priceResult != 0) {
                    return priceResult;
                } else {
                    // 3. 如果价格相等，再比较销量 (降序：p2 - p1)
                    return p2.sales - p1.sales;
                }
            }
        });

        // 输出验证
        System.out.println("--- 排序后结果 ---");
        for (Product p : products) {
            System.out.println(p);
        }
    }
}

```