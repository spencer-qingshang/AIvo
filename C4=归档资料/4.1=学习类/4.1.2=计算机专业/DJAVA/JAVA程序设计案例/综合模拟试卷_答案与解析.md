# 《程序设计入门-Java》综合模拟试卷 (V3.0) - 答案与解析

---

## 第一部分：单项选择题

**1. (第一章)**
   *   **正确答案：B. JRE (Java Runtime Environment)**
   *   **解析：**
       *   **JVM (虚拟机)** 是运行Java程序的核心，但它需要核心类库才能工作。
       *   **JRE (运行环境)** = JVM + 核心类库。因此，要运行一个编译好的Java程序，最少需要安装JRE。
       *   **JDK (开发工具包)** = JRE + 开发工具（如编译器`javac.exe`）。只有在需要编译源代码（开发）时才需要JDK。
       *   您的答案是C，这是常见的误解。可以记为：开发用JDK，运行用JRE。

**2. (第二章)**
   *   **正确答案：C. `public`**
   *   **解析：** `public` 是Java的关键字，关键字不能用作标识符（变量名、方法名、类名等）。`_` 和 `$` 都是合法的标识符开头字符。

**3. (第二章)**
   *   **正确答案：C. `byte b = 128;`**
   *   **解析：** 您想的没错，`byte` 类型的取值范围是 **-128 到 127**。128超出了其上限，因此会导致编译错误。A中的`long`类型数字末尾加`L`是正确的，B中`float`类型数字末尾加`f`是正确的，D中`char`可以存储一个汉字，因为Java的`char`是2个字节的Unicode字符。

**4. (第三章)**
   *   **正确答案：B. `switch`语句的表达式可以是 `long` 类型。**
   *   **解析：** 您答对了。关于`switch`支持的类型，您可以这样记忆：
       *   **基本整型（但不含long）**：`byte`, `short`, `int`, `char`。
       *   **特殊引用类型**：`String` (从JDK 7开始支持) 和 `enum` (枚举类型)。
       *   **不支持的常见类型**：`long`, `float`, `double`, `boolean`。

**5. (第三章)**
   *   **正确答案：B. `1 3 `**
   *   **解析：** 您的答案是D，我们来一步步分析循环：
       *   `i = 0`: `i % 2 == 0`为真，执行`i++`（`i`变为1），然后`continue`，跳过本次循环的`System.out.print`。
       *   `i = 1`: `i % 2 == 0`为假，执行`System.out.print(1)`，然后`i++`（`i`变为2）。
       *   `i = 2`: `i % 2 == 0`为真，执行`i++`（`i`变为3），然后`continue`。
       *   `i = 3`: `i % 2 == 0`为假，执行`System.out.print(3)`，然后`i++`（`i`变为4）。
       *   `i = 4`: `i % 2 == 0`为真，执行`i++`（`i`变为5），然后`continue`。
       *   `i = 5`: `while(5 < 5)`为假，循环结束。
       *   所以最终输出是 "1 3 "。

**6. (第四章)**
   *   **正确答案：D. `arr.length`**
   *   **解析：** `length` 是数组的一个**属性**，不是方法，所以没有括号。`length()` 是字符串获取长度的方法，`size()` 是集合（如List）获取大小的方法。

**7. (第五章)**
   *   **正确答案：D. `static`方法可以被子类重写（Override）。**
   *   **解析：** 您答对了，并且这个知识点确实非常重要。`static`方法属于类，它在编译时就已经确定了（称为静态绑定）。而方法重写（Override）是多态的表现，它是在运行时根据对象的实际类型来确定调用哪个方法（称为动态绑定）。因此，`static`方法可以被子类**隐藏**（子类定义一个同名的`static`方法），但**不能被重写**。简单记：`static` 和 `Override` 是冲突的。

**8. (第六章)**
   *   **正确答案：D. 抽象**
   *   **解析：** Java面向对象的三大特征是**封装、继承、多态**。抽象（`abstract`）是实现多态和继承的一种重要机制，但它本身不属于三大基本特征之一。

**9. (第六章)**
   *   **正确答案：B. `obj instanceof String` 的结果是 `true`。**
   *   **解析：** `instanceof` 用于判断一个对象是否是某个类（或其子类）的实例。
       *   A: `obj`是`Object`的子类实例，所以`obj instanceof Object`为`true`。
       *   B: `obj`的实际类型是`String`，所以`obj instanceof String`为`true`。
       *   C: `obj`是`String`类型，不是`Integer`类型，所以`obj instanceof Integer`为`false`。
       *   D: `String`类实现了`Comparable`接口，所以`obj instanceof Comparable`为`true`，不会编译错误。

**10. (第七章)**
    *   **正确答案：D. `throws` 关键字用于在方法体内部手动抛出一个异常对象。**
    *   **解析：** `throws` 用在**方法声明处**，表示该方法**可能抛出**某种类型的异常，是给调用者看的“警告”。在方法体内部**手动抛出**一个异常对象，应该使用 `throw` 关键字。

---

## 第二部分：填空题

**11. (第一章)**
    *   **正确答案：** 半编译半解释, JVM
    *   **解析：** Java 先通过 `javac` 编译成平台无关的字节码（.class文件），再由 JVM（Java虚拟机）解释执行这些字节码。

**12. (第二章)**
    *   **正确答案：** -128, 127
    *   **解析：** 您填的-127到127是8位有符号整数常见的误区。`byte` 占8位，最高位是符号位。正数最大是 `01111111`（即127），负数最小是 `10000000`（补码表示-128）。

**13. (第三章)**
    *   **正确答案：** 1
    *   **解析：** `do-while` 是“先执行，后判断”，所以无论条件是否满足，循环体至少会执行一次。

**14. (第四章)**
    *   **正确答案：** `toString`
    *   **解析：** `Arrays.toString()` 可以方便地将数组内容格式化为 `[元素1, 元素2, ...]` 的形式。

**15. (第五章)**
    *   **正确答案：** `Object`
    *   **解析：** `Object` 类是所有Java类的“祖宗”，如果一个类没有用`extends`指定父类，它就默认继承`Object`。

**16. (第八章)**
    *   **正确答案：** `Boolean`
    *   **解析：** 这是需要记忆的知识点。为您整理了所有基本类型对应的包装类：
        *   `byte` -> `Byte`
        *   `short` -> `Short`
        *   `int` -> `Integer`
        *   `long` -> `Long`
        *   `float` -> `Float`
        *   `double` -> `Double`
        *   `char` -> `Character`
        *   `boolean` -> `Boolean`
        *   (主要记住 `int` 和 `char` 的全拼即可)

---

## 第三部分：程序分析/填空题

**17. (第三章/代码填空)**
    *   **解析：** 您提出的建议非常好，这类题确实应该是填关键代码。根据您的建议，我会在下一版试卷中修改此题。如果按原题意，完整的代码是：
    ```java
    if (i % 2 == 0) {
        System.out.println("这是一个偶数");
    } else {
        System.out.println("这是一个奇数");
    }
    ```

**18. (第四章/程序分析)**
    *   **输出结果：** `数组中的最大值是: 9`
    *   **解析：** 您的计算是正确的。代码的逻辑是：`max`初始为`5`，然后遍历数组，依次与`2, 8, 1, 9, 4`比较，当遇到比`max`大的数时就更新`max`的值。最终`max`会更新为`9`。您提出的难度建议我也收到了，会在新试卷中设计更复杂的程序分析题。

**19. (第五章/代码填空)**
    *   **填空代码：**
    ```java
    public static int add(int a, int b) {
        return a + b;
    }
    ```
    *   **解析：** `main`方法是`static`的，它只能直接调用其他的`static`方法。所以`add`方法也必须是`static`的。根据调用 `add(10, 5)` 可知，方法接收两个`int`参数，根据 `int result = ...` 可知，方法返回一个`int`类型的值。

**20. (第六章/程序分析)**
    *   **输出结果：** `Dog barks`
    *   **解析：** 这考察的是多态中的**方法重写**。`myAnimal` 编译时类型是`Animal`，但运行时实际指向`Dog`对象。当调用`sound()`方法时，Java会执行`Dog`类中**重写后**的方法，所以输出"Dog barks"。如果`myAnimal.fetch()`这行代码存在，**会发生编译错误**，因为`Animal`类中没有定义`fetch()`方法。

**21. (第七章/代码填空)**
    *   **填空答案：** `catch`, `ArithmeticException`, `finally`
    *   **完整代码：**
    ```java
    } catch (ArithmeticException e) {
        System.out.println("除数不能为零！");
    } finally {
        System.out.println("程序执行完毕。");
    }
    ```
    *   **解析：** `catch`用于捕获异常，括号里写异常类型。`finally`用于定义最终必须执行的代码。

---

## 第四部分：简答题

**22. (第一章)**
    *   **答案：**
        1.  **JVM (Java虚拟机)**：是Java程序运行的核心，负责解释执行字节码。它是实现“一次编译，到处运行”的关键。
        2.  **JRE (Java运行环境)**：包含了JVM和Java程序运行所必需的核心类库。只安装JRE就可以运行Java程序。
        3.  **JDK (Java开发工具包)**：包含了JRE和Java开发工具（如编译器`javac`、调试器等）。开发Java程序必须安装JDK。
        *   **关系：** JDK > JRE > JVM (范围上，JDK包含JRE，JRE包含JVM)。

**23. (第三章)**
    *   **答案：**
        *   **`break`**：意为“终止/跳出”。它会立即**彻底结束**当前所在的整个循环结构，程序将跳转到循环体之后的第一条语句继续执行。
        *   **`continue`**：意为“继续/跳过”。它会**跳过本次循环中尚未执行的剩余代码**，并立即开始下一次循环的判断和执行。它只结束“本次”，而不是“整个”循环。

**24. (第八章)**
    *   **答案：**
        *   **主要区别：**
            1.  **可变性**：`String`是**不可变**的（Immutable），一旦创建其内容就不能被修改。任何对`String`的修改操作（如拼接）都会在内存中创建一个新的`String`对象。`StringBuffer`是**可变**的（Mutable），它的所有修改操作都是在同一个对象上进行的，不会创建新对象。
            2.  **效率**：在进行少量字符串操作时，两者效率差别不大。但在大量、频繁地拼接或修改字符串时，`StringBuffer`的效率远高于`String`，因为它避免了创建大量垃圾对象。
            3.  **线程安全**：`StringBuffer`是线程安全的，适合在多线程环境中使用。还有一个`StringBuilder`类，功能与`StringBuffer`几乎一样，但不是线程安全的，因此在单线程环境下效率更高。
        *   **适用场景：**
            *   **`String`**：适用于字符串内容很少或几乎不改变的场景。例如，作为常量、配置信息、方法参数等。
            *   **`StringBuffer`**：适用于需要频繁修改和拼接字符串的场景，尤其是在多线程环境中（如用作日志记录的缓冲区）。

---

## 第五部分：程序设计题

**25. (第四章)**
    *   **参考代码：**
    ```java
    public int findIndex(int[] arr, int target) {
        // 先判断数组是否有效，这是一个好习惯
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // 找到目标，立即返回索引
            }
        }
        
        return -1; // 整个循环结束都没找到，返回-1
    }
    ```

**26. (综合应用 - 第五章/第八章)**
    *   **参考代码：**
    ```java
    import java.util.Objects;

    public class Product {
        private String name;
        private double price;

        // 1. 构造方法
        public Product(String name, double price) {
            this.name = name;
            this.price = price;
        }

        // 2. get 方法
        public String getName() {
            return name;
        }

        public double getPrice() {
            return price;
        }

        // 3. 重写 toString 方法
        @Override
        public String toString() {
            return "Product{name='" + name + "', price=" + price + "}";
        }

        // 4. 重写 equals 方法
        @Override
        public boolean equals(Object o) {
            // 如果是同一个对象，直接返回true
            if (this == o) return true;
            // 如果对象为null或类型不同，返回false
            if (o == null || getClass() != o.getClass()) return false;
            // 向下转型
            Product product = (Product) o;
            // 比较关键属性：double用Double.compare，对象用Objects.equals
            return Double.compare(product.price, price) == 0 &&
                   Objects.equals(name, product.name);
        }
    }
    ```
