# 1. 抽象类

## 识记：

### 抽象类的概念、作用及应用场景；**abstract抽象关键字。**

- **概念**：一种**“残缺”**的类，它只定义了“做什么”（标准），但没定义“怎么做”（具体实现）。

- **关键字**：**abstract** （抽象的）。

- **作用**：

- **强制规范**：强制子类必须实现特定的功能（不实现就报错）。

- **代码复用**：抽象类中可以写普通方法让子类继承。

- **应用场景**：当父类无法确定某些方法的具体实现时。

- *例子*：Animal 类都有 eat() 行为，但猫吃鱼、狗吃肉，父类没法写死，只能定义为**抽象方法**。

## 领会：

### 抽象类及抽象方法的定义。

**A. 抽象类**

- **定义**：public abstract class 类名 {}

- **铁律（必考）**：

- 抽象类**不能被实例化**（不能 new 对象）。

- 抽象类里**可以有构造方法**（给子类初始化用的）。

- 抽象类里**可以没有**抽象方法（但有抽象方法的类**必须**是抽象类）。

**B. 抽象方法**

- **定义**：public abstract void 方法名();

- **特征**：

- **没有方法体**（没有大括号 {}），直接以分号 ; 结束。必须存在于抽象类中。

## 应用：

### 能根据特定场景设计抽象类及抽象方法；

**设计原则**

- 父类（抽象类）：只管定规矩（抽象方法）。

- 子类（具体类）：负责干实事（重写/实现抽象方法）。

### 通过继承使用抽象类。

```java
// 1. 定义抽象父类 (Shape)
abstract class Shape {
    String color; // 普通属性
    
    // 抽象方法：算面积 (具体的图形算法不同，所以抽象)
    public abstract double area(); 
    
    // 普通方法：大家都能用
    public void setColor(String c) {
        this.color = c;
    }
}

// 2. 定义具体子类 (Circle)
class Circle extends Shape {
    double r;
    
    // 3. 必须重写父类的抽象方法 (否则 Circle 也得变成 abstract)
    @Override
    public double area() {
        return 3.14 * r * r;
    }
}

// 4. 使用 (多态)
// Shape s = new Shape(); // ❌ 报错！抽象类不能 new
Shape s = new Circle();   // ✅ 对！父类引用指向子类对象
```

# 2. 接口

## 识记：

### 接口的作用及应用场景、**关键字interface、implements作用**；

- **概念**：接口是一种**标准**或**规范**（Protocol），它不是类，而是对行为的抽象。

- **关键字**：

- 定义接口：**interface**

- 实现接口：**implements**

- **作用**：

- **扩展功能**：弥补 Java **单继承**的缺陷（一个类可以实现多个接口）。

- **解耦合**：定义标准（如 USB 接口），调用者和实现者分离。

- **多态**：不同对象实现同一接口，表现出不同行为。

- **应用场景**：

- 当需要让不相关的类拥有相同的行为时（如：鸟会飞，飞机也会飞，可以定义 Flyable 接口）。

## 领会：

### 接口的定义和实现方法。

**A. 成员特点（必考死规矩）**

在接口中，即使你不写，系统也会默认加上以下修饰符：

- **成员变量**：只能是**常量**。

- 默认修饰符：**public static final**

- *考点*：必须初始化赋值。

- **成员方法**：只能是**抽象方法**（JDK8 之前）。

- 默认修饰符：**public abstract**

- *考点*：不能有方法体 {}。

**B. 关系规则**

- **类与接口**：**实现**关系 (implements)。可以**多实现**（一个类实现多个接口）。

- **接口与接口**：**继承**关系 (extends)。可以**多继承**（一个接口继承多个接口）。

## 应用：

### 能根据特定场景进行接口的定义和实现。

```java
// 1. 定义接口 (interface)
public interface USB {
    // 定义常量 (默认是 public static final)
    String STANDARD = "3.0"; 
    
    // 定义抽象方法 (默认是 public abstract)
    void connect(); 
    void disconnect();
}

// 2. 实现接口 (implements)
// 必须重写接口中所有的抽象方法，否则 Mouse 也得变成抽象类
public class Mouse implements USB {
    @Override
    public void connect() {
        System.out.println("鼠标已连接，灯亮了");
    }

    @Override
    public void disconnect() {
        System.out.println("鼠标已断开");
    }
}

// 3. 测试使用 (多态)
USB u = new Mouse(); // 接口引用指向实现类对象
u.connect();
```

# 3. 异常处理

## 识记：

### 异常处理概念；**异常处理的作用及应用场景；几种异常处理方法。**

- **概念**：程序在**运行过程中**出现的非正常情况（不是语法错误），会导致程序中断。

- *顶层父类*：**Throwable**。

- *两大子类*：

- **Error**：严重错误（如内存溢出），程序**无法处理**，只能挂掉。

- **Exception**：一般异常（如空指针、除数为0），程序**可以处理**。

- **作用**：防止程序因小错误而完全崩溃，提高程序的**健壮性**（Robustness）和安全性。

- **处理方法**：

- **捕获处理**（自己解决）：try...catch...finally

- **抛出处理**（甩锅给调用者）：throws

## 领会：

### try…catch…finally、throw、throws异常处理语法应用。

**A. 捕获异常三剑客：try-catch-finally**

- **try**：包裹**可能出错**的代码（监控区域）。

- **catch**：**捕获**异常并处理（如果没异常，这里不执行）。

- *注意*：可以有多个 catch，必须**先抓小的**（子类），**后抓大的**（父类 Exception）。

- **finally**：**无论是否发生异常，永远都会执行**的代码。

- *作用*：通常用于**释放资源**（如关闭数据库连接、关闭文件）。

| B. 抛出异常双子星：throw vs throws (死记对比) | 
| -- | -- | -- |
| 特性 | throw (动词) | throws (名词/声明) | 
| 位置 | 方法体内部 | 方法声明处 | 
| 后面跟什么 | 异常对象 | 异常类名 | 
| 作用 | 制造 | 声明 | 
| 数量 | 只能抛出  | 可以声明  | 


## 应用：

### 能够采用try…catch…finally、throw、throws等对特定场景代码进行异常处理。

```java
场景 1：除法运算（try-catch-finally 自己处理）
任务：计算除法，防止除数为 0，且最后必须打印“结束”。
public static void div(int a, int b) {
    try {
        // 1. 可能出事的代码
        int result = a / b;
        System.out.println("结果是：" + result);
    } catch (ArithmeticException e) {
        // 2. 出事了怎么办
        System.out.println("出错了：除数不能为0！");
    } catch (Exception e) {
        // 3. 兜底处理
        System.out.println("发生了其他错误");
    } finally {
        // 4. 善后工作 (必执行)
        System.out.println("程序运行结束");
    }
}

场景 2：定义方法抛出异常（throws + throw 甩锅处理）
任务：定义一个设置年龄的方法，如果年龄为负数，就抛出异常告诉调用者。

// 1. 在方法声明处用 throws 警告调用者
public static void setAge(int age) throws Exception {
    if (age < 0) {
        // 2. 在方法体内用 throw 手动抛出异常对象
        throw new Exception("年龄不能为负数！"); 
    }
    System.out.println("年龄设置为：" + age);
}

// 3. 调用者必须处理这个异常 (继续 throws 或者 try-catch)
public static void main(String[] args) {
    try {
        setAge(-5);
    } catch (Exception e) {
        System.out.println(e.getMessage()); // 打印异常信息
    }
}
```