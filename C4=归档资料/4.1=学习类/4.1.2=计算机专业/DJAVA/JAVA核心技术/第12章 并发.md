## 12.1 什么是线程

- 线程是程序中“并发执行”的最小单位。一个 Java 进程可以包含多个线程，它们共享同一块内存（堆、静态区），各自有独立的栈和执行路径。

- 作用：把一项程序工作拆成多个可同时推进的子任务，比如一边下载文件、一边刷新进度条。

- 代价与风险：共享内存带来数据竞争、可见性和有序性问题，需要用同步手段（如 synchronized、Lock、Atomic、volatile）来保证正确性。

- 使用建议：通常通过线程池（ExecutorService）管理线程更安全高效；直接 new Thread 适合演示或一次性的小任务。

```java
//目标：启动一个后台线程打印 5 次“工作中…”，主线程同时打印“主线程…”。你会看到两个输出交错出现，体现并发执行。
public class SimpleThreadDemo {
    public static void main(String[] args) throws InterruptedException {
        // 1) 定义一个要在新线程中执行的任务（实现 Runnable）
        Runnable worker = () -> {
            for (int i = 1; i <= 5; i++) {
                System.out.println("[Worker] 工作中 " + i);
                try { Thread.sleep(200); } catch (InterruptedException e) {
                    System.out.println("[Worker] 被中断，准备退出");
                    return;
                }
            }
            System.out.println("[Worker] 完成");
        };

        // 2) 创建并启动线程
        Thread t = new Thread(worker, "Worker-Thread");
        t.start();

        // 3) 主线程继续干自己的事
        for (int i = 1; i <= 5; i++) {
            System.out.println("[Main] 主线程 " + i);
            Thread.sleep(150);
        }

        // 4) 等待子线程结束（可选）
        t.join();
        System.out.println("[Main] 结束");
    }
}
//new Thread(runnable).start() 会启动一个新线程并执行 runnable.run() 的代码。
//Thread.sleep(ms) 让当前线程短暂休眠，方便观察交错输出（实际项目中常用于节流或等待条件）。
//t.join() 让主线程等待 t 执行完再继续，常用来协调结束顺序。

import java.util.concurrent.*;

public class ExecutorDemo {
    public static void main(String[] args) throws Exception {
        ExecutorService pool = Executors.newFixedThreadPool(2);

        Future<?> f = pool.submit(() -> {
            for (int i = 1; i <= 5; i++) {
                System.out.println("[Worker] 工作中 " + i);
                try { Thread.sleep(200); } catch (InterruptedException e) {
                    System.out.println("[Worker] 被中断");
                    Thread.currentThread().interrupt();
                }
            }
        });

        for (int i = 1; i <= 5; i++) {
            System.out.println("[Main] 主线程 " + i);
            Thread.sleep(150);
        }

        f.get();           // 等待任务结束
        pool.shutdown();   // 关闭线程池
    }
}


```

## 12.2 线程状态

- New（新建）

- Runnable（可运行）

- Blocked（阻塞）

- Waiting（等待）

- Timed waiting（计时等待）

- Terminated（已终止）

### 12.2.1 新建

当用

### 12.2.2 可运行

线程调用 start() 后进入“可运行”队列但不一定立刻运行；操作系统按时间片与优先级抢占调度，线程会被轮换暂停；多核可同时跑（并行），单核只能轮流跑（并发）。[](https://zzy979.github.io/posts/java-note-v1ch12-concurrency/#1222-%E5%8F%AF%E8%BF%90%E8%A1%8C)

### 12.2.3 阻塞和等待

- new：新建状态。你 new 了线程，但还没 start。

- runnable：可运行状态。已经 start，排队等 CPU 或正在 CPU 上跑（具体跑不跑取决于调度器）。

- blocked：阻塞状态。去抢“内置锁”（synchronized 的那种）但锁被别人占着，只能在门口干等。

- waiting：等待状态。不是在门口抢锁，而是自愿进入等候区，等别人来“叫你”（notify/notifyAll）或等 join 的线程结束。

- timed waiting：计时等待。也是等候区，但设了闹钟（sleep / 带超时的 wait/join/Lock/Condition 等），到点就自动醒。

- terminated：终止状态。run() 跑完，线程生命周期结束。

[](https://zzy979.github.io/posts/java-note-v1ch12-concurrency/#1223-%E9%98%BB%E5%A1%9E%E5%92%8C%E7%AD%89%E5%BE%85)

### 12.2.4 已终止

- run()方法正常退出

- 未捕获的异常终止了run()方法

## 12.3 线程属性

### 12.3.1 中断线程

除了

当对一个线程调用

### 12.3.2 守护线程

可以通过调用[](https://zzy979.github.io/posts/java-note-v1ch12-concurrency/#1232-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B)

### 12.3.3 线程名

```java
var t = new Thread(runnable);
t.setName("Web crawler");
```

### 12.3.4 未捕获异常的处理器

**线程的**[](https://zzy979.github.io/posts/java-note-v1ch12-concurrency/#1234-%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8)

```java
public class Demo {
  public static void main(String[] args) {
    Thread t = new Thread(() -> {
      System.out.println("工作开始");
      // 故意抛出未捕获异常
      int x = 1 / 0; // ArithmeticException
      System.out.println("这行不会执行到");
    }, "worker-1");

    // 为这个线程设置未捕获异常处理器
    t.setUncaughtExceptionHandler((thread, ex) -> {
      System.out.println("捕获到未捕获异常，线程名: " + thread.getName());
      ex.printStackTrace(System.out);
      // 这里可以：写日志、上报警、做统计、触发熔断/重启等
    });

    // 注意：即使这里包 try/catch 也捕不到 run() 的异常
    try {
      t.start();
      t.join();
    } catch (Exception e) {
      System.out.println("这里一般捕不到 run() 内的未捕获异常");
    }

    System.out.println("主线程结束");
  }
}

```

### 12.3.5 线程优先级

```java
在Java中，每个线程有一个优先级(priority)。默认情况下，线程会继承创建它的那个线程的优先级。可以用setPriority()方法改变线程的优先级。
```

## 12.4 同步

### 12.4.1 竞态条件的一个例子

在大多数实际的多线程应用中，两个或多个线程需要共享对相同数据的访问。如果两个线程访问同一个对象，并分别调用了修改该对象状态的方法，这两个线程就会相互冲突。取决于线程访问数据的次序，可能会导致对象被破坏。这种情况通常称为[](https://zzy979.github.io/posts/java-note-v1ch12-concurrency/#1241-%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90)

### 12.4.2 竞态条件详解

```java

public class RaceDemo {
    private static int count = 0; // 共享变量

    public static void main(String[] args) throws InterruptedException {
        int threads = 1000;
        Thread[] arr = new Thread[threads];

        for (int i = 0; i < threads; i++) {
            arr[i] = new Thread(() -> {
                // 非原子操作：读 -> 加一 -> 写回
                count++;
            });
        }

        for (Thread t : arr) t.start();
        for (Thread t : arr) t.join();

        System.out.println("count = " + count); // 多数情况下 < 1000
    }
}
//count++ 实际上是三个步骤：读取 count 的值、加一、写回。多个线程可能在读取时看到相同的旧值，导致彼此覆盖更新，丢失自增。

使用 synchronized 保证临界区互斥
public class FixWithSynchronized {
    private static int count = 0;
    private static final Object lock = new Object();

    public static void main(String[] args) throws InterruptedException {
        int threads = 1000;
        Thread[] arr = new Thread[threads];

        for (int i = 0; i < threads; i++) {
            arr[i] = new Thread(() -> {
                synchronized (lock) {
                    count++;
                }
            });
        }

        for (Thread t : arr) t.start();
        for (Thread t : arr) t.join();

        System.out.println("count = " + count); // 稳定输出 1000
    }
}

使用原子类 AtomicInteger（更轻量）
import java.util.concurrent.atomic.AtomicInteger;

public class FixWithAtomic {
    private static final AtomicInteger count = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        int threads = 1000;
        Thread[] arr = new Thread[threads];

        for (int i = 0; i < threads; i++) {
            arr[i] = new Thread(() -> {
                count.incrementAndGet(); // 原子自增
            });
        }

        for (Thread t : arr) t.start();
        for (Thread t : arr) t.join();

        System.out.println("count = " + count.get()); // 稳定输出 1000
    }
}
```

```

### 12.4.3 锁对象

两种机制可以防止代码块并发访问：

```java
//synchronized 使用的是对象的内置监视器锁，退出同步块或同步方法时会自动释放锁，无需手动“解锁”。
//正确范式：尽量缩小同步块范围。

public class SyncUnlockDemo {
    private final Object lock = new Object();
    private int counter = 0;

    public void inc() {
        // 进入 synchronized 块时加锁，退出该块时自动解锁
        synchronized (lock) {
            counter++;
        } // 到这里自动释放 lock
    }
}

//ReentrantLock 需要手动 unlock()，且必须放在 finally 中，避免异常导致锁无法释放而“死锁”。
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockUnlockDemo {
    private final ReentrantLock lock = new ReentrantLock();
    private int counter = 0;

    public void inc() {
        lock.lock();          // 加锁
        try {
            counter++;
            // 这里可能抛出异常，但 finally 中会确保解锁
        } finally {
            lock.unlock();     // 在 finally 中释放锁
        }
    }
}

//避免长期阻塞，可以用 tryLock() 或 tryLock(timeout, unit)。
//获得锁后，依然必须 finally unlock()；没获得锁就不要 unlock()。
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class TryLockDemo {
    private final ReentrantLock lock = new ReentrantLock();
    private int counter = 0;

    public void incSafely() throws InterruptedException {
        if (lock.tryLock(200, TimeUnit.MILLISECONDS)) { // 尝试在200ms内获得锁
            try {
                counter++;
            } finally {
                lock.unlock(); // 只在成功加锁后解锁
            }
        } else {
            System.out.println("没拿到锁，放弃这次操作");
        }
    }
}

//使用 ReadWriteLock 时，读锁与写锁分别加解锁，注意成对出现。
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockDemo {
    private final ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
    private final ReentrantReadWriteLock.ReadLock r = rw.readLock();
    private final ReentrantReadWriteLock.WriteLock w = rw.writeLock();
    private int data = 0;

    public int read() {
        r.lock();
        try {
            return data;
        } finally {
            r.unlock(); // 释放读锁
        }
    }

    public void write(int v) {
        w.lock();
        try {
            data = v;
        } finally {
            w.unlock(); // 释放写锁
        }
    }
}


```

### 12.4.4 条件对象

条件对象是和显式锁（如 ReentrantLock）配套使用的一种线程协调机制。它允许线程在某个“条件不满足”时挂起等待，当条件变为满足时由其他线程发出信号唤醒。[](https://zzy979.github.io/posts/java-note-v1ch12-concurrency/#1244-%E6%9D%A1%E4%BB%B6%E5%AF%B9%E8%B1%A1)

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class BoundedBuffer<T> {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notEmpty = lock.newCondition();
    private final Condition notFull  = lock.newCondition();

    private T item = null; // 容量=1
    private boolean hasItem = false;

    // 生产：缓冲满则等待
    public void put(T x) throws InterruptedException {
        lock.lock();
        try {
            while (hasItem) {           // 用 while 防止虚假唤醒
                notFull.await();        // 释放锁并等待“变不满”
            }
            item = x;
            hasItem = true;
            notEmpty.signal();          // 通知等待取的线程
        } finally {
            lock.unlock();
        }
    }

    // 消费：缓冲空则等待
    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (!hasItem) {
                notEmpty.await();       // 释放锁并等待“变非空”
            }
            T x = item;
            item = null;
            hasItem = false;
            notFull.signal();           // 通知等待放的线程
            return x;
        } finally {
            lock.unlock();
        }
    }

    // 简单自测
    public static void main(String[] args) {
        BoundedBuffer<Integer> buf = new BoundedBuffer<>();
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 5; i++) {
                    buf.put(i);
                    System.out.println("生产: " + i);
                }
            } catch (InterruptedException ignored) {}
        });

        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 5; i++) {
                    int v = buf.take();
                    System.out.println("消费: " + v);
                }
            } catch (InterruptedException ignored) {}
        });

        producer.start();
        consumer.start();
    }
}
```

### 12.4.5 synchronized关键字

- 功能：为一段代码或一个方法加上“内置监视器锁”，保证同一时刻只有一个线程能进入这段临界区，从而实现互斥与可见性。

```java
public class SyncCounterDemo {
    private int counter = 0;
    private final Object lock = new Object(); // 自定义锁对象（也可直接用 this）

    // 同步代码块：锁的是 lock 对象
    public void inc() {
        synchronized (lock) {
            counter++;
        } // 退出大括号自动释放锁
    }

    // 同步实例方法：等价于 synchronized(this) 包住整个方法体
    public synchronized int get() {
        return counter;
    }

    public static void main(String[] args) throws InterruptedException {
        SyncCounterDemo demo = new SyncCounterDemo();
        Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) demo.inc(); });
        Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) demo.inc(); });

        t1.start(); t2.start();
        t1.join();  // 等待线程结束
        t2.join();

        System.out.println("结果: " + demo.get()); // 预期 20000
    }
}
```

### 12.4.6 同步块

- 同步块就是用 synchronized(某个锁对象) { ...临界区代码... } 包起来的一段代码。

- 作用：让同一时刻只有一个线程能执行这段受保护的“临界区”，从而保证共享数据的互斥访问与可见性。

- 锁对象可以是任意引用，但应当是固定且私有的对象（例如私有的 final 成员），否则容易“锁不住”。

```java

public class SyncBlockExample {
    private int count = 0;                 // 共享可变状态
    private final Object lock = new Object(); // 专用锁对象

    public void add() {
        // 只有这几行需要互斥，锁粒度更小
        synchronized (lock) {
            count++;
        } // 离开大括号自动释放锁
    }

    public int get() {
        // 读取也可不加锁（若需强一致，也可 synchronized(lock) 保护）
        return count;
    }

    public static void main(String[] args) throws InterruptedException {
        SyncBlockExample ex = new SyncBlockExample();

        Thread t1 = new Thread(() -> { for (int i = 0; i < 10000; i++) ex.add(); });
        Thread t2 = new Thread(() -> { for (int i = 0; i < 10000; i++) ex.add(); });

        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println("count = " + ex.get()); // 预期：20000
    }
}


```

### 12.4.7 监视器概念

- 概念（并发原语）：监视器是一种把“数据 + 对这些数据的互斥访问 + 条件等待/唤醒机制”封装在一起的同步结构。它保证同一时刻只有一个线程在监视器内部执行临界区代码，并支持线程在条件不满足时等待、条件满足时被唤醒。

```java
public class SimpleMonitorBuffer<T> {
    private T item;          // 容量=1
    private boolean hasItem; // 是否有货

    // 生产
    public synchronized void put(T x) throws InterruptedException {
        while (hasItem) {     // 条件不满足 -> 在该对象监视器的条件队列上等待
            this.wait();      // 释放监视器锁，进入等待；被唤醒后会重新竞争锁
        }
        item = x;
        hasItem = true;
        this.notifyAll();     // 条件改变(非空)，唤醒在该监视器上等待的线程
    }

    // 消费
    public synchronized T take() throws InterruptedException {
        while (!hasItem) {    // 条件不满足 -> 等待
            this.wait();
        }
        T x = item;
        item = null;
        hasItem = false;
        this.notifyAll();     // 条件改变(不满)，唤醒等待的生产者
        return x;
    }

    public static void main(String[] args) {
        SimpleMonitorBuffer<Integer> buf = new SimpleMonitorBuffer<>();
        Thread p = new Thread(() -> {
            try {
                for (int i = 1; i <= 3; i++) {
                    buf.put(i);
                    System.out.println("生产: " + i);
                }
            } catch (InterruptedException ignored) {}
        });
        Thread c = new Thread(() -> {
            try {
                for (int i = 1; i <= 3; i++) {
                    System.out.println("消费: " + buf.take());
                }
            } catch (InterruptedException ignored) {}
        });
        p.start(); c.start();
    }
}
```

### 12.4.8 volatile字段

- 可见性保证：对 volatile 变量的写入会立刻刷新到主内存，后续其他线程读取该变量一定能看到最新值。

- 禁止指令重排序（与该变量相关）：在程序次序上，volatile 写之前的操作不会被重排到写之后；volatile 读之后的操作不会被重排到读之前。这提供了有限的有序性。

- 不保证原子性（除了单次读/写本身是原子的）：像 i++、count += 1 这样的复合操作仍然不是线程安全的，即使 count 是 volatile。

```java
public class VolatileStopFlag {
    // 可见性需求：让工作线程及时看到最新的停止信号
    private volatile boolean stop = false;

    public void work() {
        while (!stop) {
            // 执行一些任务
            // doWork();
        }
        System.out.println("工作线程已感知 stop=true，准备退出");
    }

    public void stopWork() {
        stop = true; // volatile 写，使其他线程立即可见
    }

    public static void main(String[] args) throws InterruptedException {
        VolatileStopFlag demo = new VolatileStopFlag();
        Thread t = new Thread(demo::work);
        t.start();

        Thread.sleep(500);   // 模拟运行一会
        demo.stopWork();     // 通知停止

        t.join();
        System.out.println("已安全停止");
    }
}
```

### 12.4.9 final变量

```java
final var accounts = new HashMap<String, Double>();
```

### 12.4.10 原子性

java.util.concurrent.atomic[](https://zzy979.github.io/posts/java-note-v1ch12-concurrency/#12410-%E5%8E%9F%E5%AD%90%E6%80%A7)

- 什么是原子性

- 原子性指一个操作要么全部执行完毕，要么完全不执行，中间不会被线程切换打断，也不会被其他线程看到“半完成”的状态。

- 在并发环境下，原子性是线程安全的基础之一（另两个常提的是可见性和有序性）。

- 哪些操作在 Java 中是原子的

- 单个对引用类型和大多数基本类型（boolean、byte、short、int、char、float）变量的读/写是原子的。

- long 和 double 的读/写在早期 JVM 规范里不保证原子性，但在现代主流 JVM 上已实现为原子（仍建议不要依赖历史例外）。

- 复合操作（如 i++、i=i+1、check-then-act 等）不是原子的，因为它们包含多个步骤：读-改-写。

```java
import java.util.concurrent.atomic.AtomicInteger;

public class CounterAtomic {
    private static final AtomicInteger counter = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(CounterAtomic::inc10k);
        Thread t2 = new Thread(CounterAtomic::inc10k);
        t1.start(); t2.start();
        t1.join(); t2.join();
        System.out.println(counter.get()); // 稳定为 20000
    }

    static void inc10k() {
        for (int i = 0; i < 10_000; i++) {
            counter.incrementAndGet(); // 原子自增
        }
    }
}

public class CounterSynchronized {
    private static int counter = 0;

    public static synchronized void inc() {
        counter++; // 在锁内，整体原子
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> { for (int i=0;i<10_000;i++) inc(); });
        Thread t2 = new Thread(() -> { for (int i=0;i<10_000;i++) inc(); });
        t1.start(); t2.start();
        t1.join(); t2.join();
        System.out.println(counter); // 20000
    }
}

```

### 12.4.11 死锁

- 死锁是指多个线程彼此持有对方需要的锁并相互等待，导致所有相关线程都无法继续执行的状态。

- 形成死锁常见的四个必要条件：

1. 互斥：资源一次只能被一个线程占用

1. 占有且等待：线程已持有资源，同时申请其他资源并等待

1. 不可剥夺：资源在未使用完前不能被强制夺走

1. 循环等待：存在线程-资源的环形等待链

```java
public class DeadlockDemo {
    private static final Object LOCK_A = new Object();
    private static final Object LOCK_B = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            synchronized (LOCK_A) {
                System.out.println("T1: got A, try get B...");
                sleep(100); // 制造时序窗口
                synchronized (LOCK_B) {
                    System.out.println("T1: got B");
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (LOCK_B) {
                System.out.println("T2: got B, try get A...");
                sleep(100); // 制造时序窗口
                synchronized (LOCK_A) {
                    System.out.println("T2: got A");
                }
            }
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println("Done");
    }

    private static void sleep(long ms) {
        try { Thread.sleep(ms); } catch (InterruptedException ignored) {}
    }
}

```

### 12.4.12 为什么弃用stop和suspend方法

### 12.4.13 按需初始化

### 12.4.14 线程局部变量

- 线程局部变量指的是同一个变量名在不同线程里各自拥有独立副本，线程之间互不影响。

- 在 Java 中常用 ThreadLocal 类来实现。它不是让变量“只在当前线程可见”，而是为每个线程维护一个独立的值存储。

```java
public class ThreadLocalDemo {
    // 为每个线程提供一个独立的计数器，初始值为 0
    private static final ThreadLocal<Integer> localCounter =
            ThreadLocal.withInitial(() -> 0);

    public static void main(String[] args) throws InterruptedException {
        Runnable task = () -> {
            // 每个线程自增自己的“局部”计数器
            for (int i = 0; i < 3; i++) {
                int cur = localCounter.get();
                localCounter.set(cur + 1);
                System.out.printf("%s -> %d%n",
                        Thread.currentThread().getName(), localCounter.get());
            }
            // 用完后清理，避免复用线程（线程池）造成数据“串台”
            localCounter.remove();
        };

        Thread t1 = new Thread(task, "T1");
        Thread t2 = new Thread(task, "T2");
        t1.start(); t2.start();
        t1.join(); t2.join();
    }
}

```

## 12.5 线程安全的集合

### 12.5.1 阻塞队列

- 阻塞队列（BlockingQueue）是线程安全的队列，支持在获取元素时队列为空就等待、在放入元素时队列满了就等待的“阻塞”行为。

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

public class BlockingQueueDemo {
    private static final BlockingQueue<String> queue = new ArrayBlockingQueue<>(2);

    public static void main(String[] args) {
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 5; i++) {
                    String item = "job-" + i;
                    queue.put(item); // 队列满则阻塞等待
                    System.out.println("Produce -> " + item);
                    TimeUnit.MILLISECONDS.sleep(150);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Producer");

        Thread consumer = new Thread(() -> {
            try {
                while (true) {
                    String item = queue.take(); // 队列空则阻塞等待
                    System.out.println("Consume <- " + item);
                    TimeUnit.MILLISECONDS.sleep(300);
                    if ("job-5".equals(item)) break; // 简单结束条件
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Consumer");

        producer.start();
        consumer.start();
    }
}

```

### 12.5.2 并发映射、集和队列

- 并发映射（Concurrent Map）

- 代表：ConcurrentHashMap、ConcurrentSkipListMap（有序）

- 特点：支持多线程安全地 put/get/update，内部采用分段/桶级CAS、红黑树化等手段减少锁竞争；部分操作是弱一致或分阶段遍历。

- 并发集合（Concurrent Set）

- 代表：ConcurrentSkipListSet（有序）、CopyOnWriteArraySet、基于 ConcurrentHashMap 的 KeySetView

- 特点：线程安全的 Set；有的适合读多写少（CopyOnWrite），有的适合高并发读写（SkipList/CHM）。

- 并发队列（Concurrent Queue）

- 代表：ConcurrentLinkedQueue（无界非阻塞）、LinkedBlockingQueue/ArrayBlockingQueue（阻塞队列）、SynchronousQueue、PriorityBlockingQueue 等

- 特点：线程安全入队/出队；阻塞队列在满/空时会等待，非阻塞队列采用无锁算法（CAS）高并发。

```java
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.LongAdder;

public class ConcurrentContainersDemo {

    public static void main(String[] args) throws InterruptedException {
        // 1) 非阻塞并发队列：装待处理的单词
        ConcurrentLinkedQueue<String> tasks = new ConcurrentLinkedQueue<>(
                Arrays.asList("apple", "banana", "apple", "orange", "banana", "apple"));

        // 2) 并发映射：统计词频（LongAdder 在高并发下比 AtomicLong 更友好）
        ConcurrentHashMap<String, LongAdder> freq = new ConcurrentHashMap<>();

        // 3) 线程池并发处理
        int n = 4;
        ExecutorService pool = Executors.newFixedThreadPool(n);
        CountDownLatch latch = new CountDownLatch(n);

        for (int i = 0; i < n; i++) {
            pool.execute(() -> {
                String w;
                while ((w = tasks.poll()) != null) { // 并发安全出队
                    freq.computeIfAbsent(w, k -> new LongAdder()).increment(); // 并发安全计数
                }
                latch.countDown();
            });
        }

        latch.await();
        pool.shutdown();

        // 4) 将结果按频次排序（演示并发Map的结果使用）
        List<Map.Entry<String, LongAdder>> list = new ArrayList<>(freq.entrySet());
        list.sort(Comparator.comparingLong(e -> -e.getValue().longValue()));

        for (Map.Entry<String, LongAdder> e : list) {
            System.out.println(e.getKey() + " -> " + e.getValue().longValue());
        }
    }
}

```

### 12.5.3 映射条目的原子更新

- 映射条目的原子更新：对 Map 中某个键对应的值进行读取-计算-写回这一整步操作，在并发下作为不可分割的原子动作完成，避免竞态条件。

- 典型问题：用 get + put 自己拼接更新，在多线程并发时会丢更新或覆盖彼此结果。

- 解决办法：使用 ConcurrentHashMap 提供的原子方法，如 compute、computeIfAbsent、merge、putIfAbsent 等，让 Map 内部用合适的同步/CAS 保证更新原子性。

```java
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class AtomicUpdateDemo {
    public static void main(String[] args) throws InterruptedException {
        Map<String, Integer> freq = new ConcurrentHashMap<>();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                // 对 key="apple" 做原子累加
                freq.merge("apple", 1, (oldVal, x) -> oldVal + x);
                // 等价写法：freq.compute("apple", (k, v) -> v == null ? 1 : v + 1);
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println("apple -> " + freq.get("apple")); // 期望=2000
    }
}

```

### 12.5.4 并发散列映射的批操作

### 12.5.5 并发集视图

### 12.5.6 写时拷贝数组

### 12.5.7 并行数组算法

### 12.5.8 早期的线程安全集合

## 12.6 任务和线程池

### 12.6.1 Callable和Future

### 12.6.2 执行器

### 12.6.3 控制任务组

### 12.6.4 Fork-Join框架

## 12.7 异步计算框架

### 12.7.1 可完成Future

### 12.7.2 组合可完成Future

### 12.7.3 用户界面回调中的长时间运行任务

## 12.8 进程

### 12.8.1 创建进程

### 12.8.2 运行进程

### 12.8.3 进程句柄