# 第五章：类、对象与继承 - 必备关键知识点

本章是面向对象编程 (OOP) 的核心，重点在于理解从抽象的“模板”到具体的“实例”的过程，以及类与类之间的关系。

---

## 1. 面向对象三大特征 (复习)

*   **封装 (Encapsulation)**：隐藏内部细节，提供公共接口。通过 `private` 关键字实现。
*   **继承 (Inheritance)**：子类复用和扩展父类的代码。通过 `extends` 关键字实现。
*   **多态 (Polymorphism)**：同一行为，不同表现。通过**继承、方法重写、父类引用指向子类对象**实现。

---

## 2. 类与对象

*   **类 (Class)**：
    *   **关键字**：`class`
    *   **概念**：对象的**模板**或图纸，是对一类事物的抽象描述。
    *   **组成**：**属性** (成员变量) 和 **行为** (成员方法)。
*   **对象 (Object)**：
    *   **关键字**：`new`
    *   **概念**：类的**实例**，是看得见、摸得着的具体实体。
    *   **创建语法**：`类名 对象名 = new 类名();`
    *   **使用**：通过 **`.`** 操作符访问对象的属性和方法（例如 `student.name` 或 `student.study()`）。

---

## 3. 构造方法 (Constructor)

*   **作用**：在 `new` 对象时被自动调用，用于**初始化对象**的属性。
*   **核心规则 (必记)**：
    1.  方法名必须与**类名完全相同**。
    2.  **没有返回值类型**，连 `void` 都不能写。
*   **默认构造方法**：如果一个类没有手动定义任何构造方法，Java编译器会自动提供一个无参数的、方法体为空的默认构造方法。一旦手动定义了任何构造方法，这个默认的就不再提供了。
*   **重载 (Overload)**：一个类可以有多个同名但**参数列表不同**的构造方法，这称为构造方法的重载。

---

## 4. `this` 和 `static` 关键字

*   **`this` 关键字**：
    *   **含义**：代表**当前对象**的引用。
    *   **主要用途**：
        1.  **区分同名变量**：在方法中，当局部变量（参数）与成员变量重名时，使用 `this.成员变量名` 来明确指定访问的是成员变量。例如 `this.name = name;`。
        2.  **调用本类构造器**：在构造方法中，使用 `this(...)` 来调用本类的其他构造方法。此语句**必须**放在构造方法的第一行。
*   **`static` 关键字**：
    *   **含义**：静态的，表示成员属于**类**本身，而不是某个具体对象。被所有对象**共享**。
    *   **静态变量 (类变量)**：所有对象共享同一份数据。推荐通过**类名直接调用** (`类名.静态变量名`)。
    *   **静态方法 (类方法)**：
        *   可以直接通过**类名调用**，无需创建对象。
        *   **核心规则 (必记)**：静态方法中**不能**直接访问非静态的成员（变量或方法），因为非静态成员依赖于具体对象，而调用静态方法时可能还没有对象存在。简单记：**“静态只能访问静态”**。
    *   **静态代码块**：
        *   **语法**：`static { ... }`
        *   **执行时机**：在**类加载时**执行，且**只执行一次**。通常用于加载驱动、初始化静态资源等一次性操作。

---

## 5. 继承 (Inheritance)

*   **关键字**：`extends`
*   **概念**：子类继承父类，可以获得父类的所有非 `private` 成员。
*   **核心规则**：Java 是**单继承**，一个子类只能有一个直接父类，但支持多层继承（A -> B -> C）。
*   **`super` 关键字**：
    *   **含义**：代表**父类**的引用。
    *   **主要用途**：
        1.  **调用父类构造器**：在子类构造方法中，使用 `super(...)` 来调用父类的构造方法。此语句也**必须**放在构造方法的第一行。(`this()` 和 `super()` 不能同时出现)。
        2.  **调用父类成员**：在子类中，使用 `super.成员方法()` 或 `super.成员变量` 来访问父类中被子类重写或隐藏的成员。
*   **方法重写 (Override)**：
    *   **概念**：子类对从父类继承来的方法不满意，可以提供一个与父类**方法签名完全相同**（方法名、参数列表、返回值类型都相同）的新实现。
    *   **注解**：推荐在重写的方法上加上 `@Override` 注解，可以让编译器帮忙检查是否满足重写规则。
    *   **`重写` vs `重载` (高频对比)**：
        | 对比项     | 重载 (Overload) | 重写 (Override) |
        | :--------- | :-------------- | :-------------- |
        | **位置**   | 同一个类中      | 父子类之间      |
        | **方法名** | 必须相同        | 必须相同        |
        | **参数列表** | **必须不同**    | **必须相同**    |
        | **返回值** | 无要求          | 必须相同或兼容  |

---

## 6. 多态 (Polymorphism)

*   **核心体现**：
    1.  **方法重写**：子类重写父类方法。
    2.  **向上转型**：父类引用指向子类对象。`父类类型 变量名 = new 子类类型();` (例如 `Animal a = new Dog();`)。
*   **向上转型后的特点**：
    *   **编译时**：变量类型是父类，只能调用父类中定义的方法。
    *   **运行时**：实际执行的是子类**重写后**的方法。
*   **`instanceof` 关键字**：
    *   **作用**：判断一个对象是否是某个类（或其子类）的实例。返回 `boolean` 值。
    *   **用途**：在进行**向下转型**（`子类类型 变量名 = (子类类型)父类引用;`）之前，使用 `instanceof` 进行判断，可以有效避免 `ClassCastException` (类型转换异常)。

---
