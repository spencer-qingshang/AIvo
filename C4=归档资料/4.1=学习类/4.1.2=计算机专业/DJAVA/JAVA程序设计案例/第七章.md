# 1. Object类

## 识记：

### Object类概念及作用；**Object常用方法** 

### 🟢 **Object类概念及作用**

- **地位**: java.lang.Object 是类层次结构的**根类**（祖宗类）。

- **继承**: Java 中所有的类都直接或间接继承自 Object 类。如果定义一个类时没有使用 extends 关键字，则默认继承 Object。

- **多态**: Object 类型的变量可以引用任意类型的对象（例如：Object obj = new Student();）。

### 🟢 **Object常用方法 **

虽然 Object 有很多方法，但大纲重点要求掌握以下两个，其余只需了解：

- **public String toString()**: 返回对象的字符串表示形式。

- **public boolean equals(Object obj)**: 指示其他某个对象是否与此对象“相等”。

- *(补充了解)* public int hashCode(): 返回对象的哈希码值（通常重写 equals 时也要重写它）。

- *(补充了解)* public final Class<?> getClass(): 返回此 Object 的运行时类。

## 领会：

### toString（）、equals（）两个方法的作用。

**A. **

- **默认行为**: 返回 类名 + @ + 16进制的哈希值 (例如 Student@1b6d3586)。

- **存在问题**: 打印对象时，默认输出的地址信息对开发者通常没有实际意义。

- **重写目的**: 为了返回对象的**属性值**（如姓名、年龄），方便打印调试和日志记录。

**B. **

- **默认行为**: 在 Object 类中，equals() 方法的底层使用的是 == 运算符。

- **==**** 的含义**: 比较两个对象的**内存地址**是否相同（即是否是同一个对象）。

- **存在问题**: 在现实业务中，我们通常认为如果两个对象的**内容**（如身份证号）一样，它们就是相等的，而不是非要内存地址一样。

- **重写目的**: 将“地址比较”改为“**内容比较**”。

## 应用：

### 能够通过覆盖toString（）实现返回特定信息；能够通过覆盖equals方法实现按特定方式进行对象相等比较。

```java
🔴 场景：定义一个 Person 类
需求:
打印 Person 对象时，输出 Person{name='xxx', age=xx} 格式。
判断两个 Person 对象时，只要 name 和 age 相同，就认为是同一个人。

import java.util.Objects;

public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // --- 1. 应用：覆盖 toString() ---
    // 目的：打印对象时输出具体内容，而不是地址
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }

    // --- 2. 应用：覆盖 equals() ---
    // 目的：比较对象的内容（属性值）是否相同
    @Override
    public boolean equals(Object o) {
        // Step 1: 如果内存地址一样，那肯定是同一个对象，直接返回 true
        if (this == o) return true;
        
        // Step 2: 如果传入的对象是 null，或者两者类型不一样，直接返回 false
        if (o == null || getClass() != o.getClass()) return false;
        
        // Step 3: 向下转型（强制类型转换），以便访问子类特有属性
        Person person = (Person) o;
        
        // Step 4: 比较所有关键属性
        // 比较基本数据类型用 ==，比较引用数据类型(String)用 equals
        // 推荐使用 Objects.equals(a, b) 工具方法防止空指针异常
        return age == person.age &&
               Objects.equals(name, person.name);
    }

    // 注意：重写 equals 通常也需要重写 hashCode（虽然大纲未强制要求，但这是最佳实践）
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}

测试代码
public class TestObject {
    public static void main(String[] args) {
        Person p1 = new Person("张三", 20);
        Person p2 = new Person("张三", 20);
        
        // 测试 toString
        // 如果没重写，输出: Person@15db9742
        // 重写后输出: Person{name='张三', age=20}
        System.out.println(p1); 

        // 测试 equals
        // 如果没重写，使用的是 ==，p1 和 p2 地址不同，返回 false
        // 重写后，比较的是内容，返回 true
        System.out.println(p1.equals(p2)); 
    }
}
```

# 2. 字符串类

## 识记：

### 字符串类概念； 

### String类与StringBuffer类的差异。

**A. String 类**

- **本质**: java.lang.String 代表字符串。

- **核心特性**: **不可变性 (Immutable)**。一旦创建，其内容也就不能被改变。任何看似修改 String 的操作（如拼接、替换），实际上都是**在内存中创建了一个新的 String 对象**，原字符串保持不变。

**B. StringBuffer 类**

- **概念**：**线程安全的可变字符序列**。

- **核心特性**：**可变性 (Mutable)**。

- 专门用来**频繁拼接**或**修改**字符串。

- 是在**同一个内存地址**上进行修改，不会产生一堆垃圾对象，效率高。

| C. 两者差异对比表 (死记) | 
| -- | -- | -- |
| 特性 | String | StringBuffer | 
| 可变性 | 不可变 | 可变 | 
| 效率 | 频繁拼接时 | 频繁拼接时 | 
| 存储 | 常量池 (字面量方式) | 堆内存 | 
| 用途 | 少量操作，做常量 | 大量拼接，做缓存 | 


## 领会：

### 能够正确使用String类与StringBuffer类定义变量。

**A. String 的两种定义方式**

- **直接赋值 (推荐)**：

- String s1 = "Hello";

- *特点*：数据存放在**字符串常量池**中，如果池子里有，直接复用（效率高）。

- **构造方法 (new)**：

- String s2 = new String("Hello");

- *特点*：不管池子里有没有，强制在**堆内存**创建一个新对象。

**B. StringBuffer 的定义方式**

- **必须用 new**：StringBuffer 不支持直接用双引号赋值。

- ❌ 错：StringBuffer sb = "Hello";

- ✅ 对：StringBuffer sb = new StringBuffer("Hello");

## 应用：

### 能够正确使用String类与StringBuffer类定义变量；能够调用字符串类常用方法进行字符串操作。

**A. String 类常用方法 (必背 TOP 5)**

- **长度**：int len = str.length(); （注意：有括号）。

- **比较内容**：boolean b = str.equals("abc"); （**绝对不能用 ==**）。

- **获取字符**：char c = str.charAt(0); （获取第0个位置的字符）。

- **截取**：String sub = str.substring(2, 5); （**含头不含尾**，包左不包右）。

- **查找**：int index = str.indexOf("a"); （找 "a" 第一次出现的索引，找不到返 -1）。

- **切割**：String[] arr = str.split(","); （按逗号切成数组）。

- **去空格**：String s = str.trim(); (去掉首尾空格)。

**B. StringBuffer 类常用方法**

- **追加 (核心)**：**sb.append("World");***作用*：在末尾添加内容。

- **插入**：sb.insert(1, "Java");*作用*：在指定索引插入内容。

- **反转**：**sb.reverse();***作用*：把字符串倒序（笔试编程题神器）。

- **转回 String**：String s = sb.toString();

```java
// String 方式 (效率低，产生了 3 个对象："A", "B", "AB")
String s = "A";
s = s + "B"; 

// StringBuffer 方式 (效率高，始终是 1 个对象)
StringBuffer sb = new StringBuffer("A");
sb.append("B");
```

# 3. 随机数

## 识记：

### Math类的random方法作用；

- **Math.random()**** 方法**

- **所属类**：java.lang.Math（不需要导包）。

- **作用**：生成一个**伪随机**的**双精度浮点数 (****double****)**。

- **范围（必考）**：**[0.0, 1.0)**

- 即：大于等于 0.0，且**严格小于** 1.0（永远取不到 1.0）。

### Random类作用。

- **Random**** 类**

- **所属包**：**java.util.Random**（使用前**必须导包**）。

- **作用**：专门用于生成各种类型（int, boolean, double...）随机数的类。

- **核心方法**：

- **nextInt(int n)**：生成 [0, n) 之间的整数（含 0，不含 n）。

## 领会：

### Math和Random产生随机数的异同及不同的应用场景。

| 特性 | Math.random() | Random 类 | 
| -- | -- | -- |
| 使用方式 | 静态方法 | 需要  | 
| 导包 | 不用 (java.lang) | 要导包 | 
| 返回值 | 只能是  | 可以是  | 
| 灵活性 | 较低（生成整数需强转） | 高 | 
| 种子 (Seed) | 不可直接设置 | 可以设置种子 (种子一样，随机序列就一样) | 


## 应用：

### 能用Math类生成随机数；

- **Math.random()**：适合**偶尔**需要一个随机数，且对范围要求简单的场景。

### 能用Random类生成随机数。

- **Random 类**：适合**大量**生成随机数，或者需要直接生成 **int 整数**的场景。

```java
A. 使用 Math.random() 生成随机数
通用公式（背诵）：生成 [min, max] 之间的整数：
(int)(Math.random() * (max - min + 1) + min)

案例 1：生成 0 ~ 9 之间的整数
// 1. 乘以 10 变成 [0.0, 10.0)
// 2. 强转 int 变成 [0, 9] (去尾法)
int num = (int)(Math.random() * 10);

案例 2：生成 1 ~ 100 之间的整数（必考）
// 范围个数 = 100 - 1 + 1 = 100
// 起始值 = 1
int result = (int)(Math.random() * 100 + 1);

B. 使用 Random 类生成随机数
步骤：
导包：import java.util.Random;
创建对象：Random r = new Random();
调用方法：r.nextInt(范围);
案例 1：生成 0 ~ 9 之间的整数
Random r = new Random();
int n = r.nextInt(10); // 括号里写10，生成的是 0~9

案例 2：生成 1 ~ 100 之间的整数
Random r = new Random();
// nextInt(100) 生成 0~99
// 再 +1 就变成了 1~100
int n = r.nextInt(100) + 1;

```

# 4. 基本类型包装类

## 识记：

### boolean、byte、char、int、short、long、float、double八种基本类型对应的包装类。

| 基本数据类型 | 包装类 | 记忆要点 | 
| -- | -- | -- |
| int | Integer | 全拼写，变化最大 | 
| char | Character | 全拼写，变化很大 | 
| byte | Byte | 首字母大写 | 
| short | Short | 首字母大写 | 
| long | Long | 首字母大写 | 
| float | Float | 首字母大写 | 
| double | Double | 首字母大写 | 
| boolean | Boolean | 首字母大写 | 


## 领会：

### 基本类型对应的包装类的及不同的作用及应用场景；

**A. 为什么要用包装类？**

- **万物皆对象**：Java 是面向对象的，但基本类型（如 int）不是对象，没法调用方法。包装类给它们穿上了一层“外衣”，让它们变成了对象。

- **集合要求（必考）**：集合（如 ArrayList, HashMap）**只能存对象**，不能存基本类型。

- ❌ ArrayList<int> （错！）

- ✅ ArrayList<Integer> （对！）

### 拆箱装箱操作。

- **装箱**：基本类型 →→ 包装类对象（把东西装进盒子里）。

- Integer i = 10; （自动装箱，JDK 5 以后支持）。

- **拆箱**：包装类对象 →→ 基本类型（把东西从盒子里拿出来）。

- int a = i; （自动拆箱）。

- *注意*：虽然现在是自动的，但要注意 null 值拆箱会报 **空指针异常**。

## 应用：

### 能用包装类进行数据类型转换。

**A. 字符串 转 基本类型 (String->int）**

- **核心方法**：**parseXxx("字符串")**

- **常用代码（背诵）**：

```java
String s = "123";

// 转 int (最常用)
int num = Integer.parseInt(s); 

// 转 double
double d = Double.parseDouble(s);
```

**B. 基本类型 转 字符串 (int->string)**

- **方法 1（推荐，最简单）**：连接空字符串。

- String s = 123 + "";

- **方法 2（专业）**：使用 String 类的静态方法。

- String s = String.valueOf(123);

- **方法 3**：使用包装类的 toString。

- String s = Integer.toString(123);

# 5. 日期时间类

## 识记：

### 日期时间类的作用；Date和Calendar类的作用。

- **java.util.Date**

- **作用**：表示特定的瞬间，精确到**毫秒**。

- **本质**：包装了一个 long 类型的数据（距离 1970年1月1日 00:00:00 的毫秒数）。

- **java.util.Calendar****作用**：日历类，用于获取或操作日期的特定部分（如年、月、日、时、分）。**特征**：它是一个**抽象类**，不能直接 new，要用静态方法获取实例。

## 领会：

### 能用Date和Calendar类生成日期对象。

**A. Date 类的生成**

- **当前时间**：Date d = new Date(); （分配时自动记录当前时间）。

- **指定时间**：Date d = new Date(long date); （传入毫秒数）。

**B. Calendar 类的生成（必考）**

- **获取实例**：**Calendar c = Calendar.getInstance();***注意*：因为是抽象类，不能写 new Calendar()。

- **常用方法**：c.get(Calendar.YEAR)：获取年。c.set(2025, 11, 25)：设置时间。c.getTime()：**把 Calendar 变成 Date 对象**。

## 应用：

### 能根据特定场景要求，正确使用Date和Calendar类生成日期对象。

```java
场景 1：获取当前时间并打印
Date now = new Date();
System.out.println(now); // 输出格式类似：Sat Dec 06 ...

场景 2：使用 Calendar 设置特定日期（比如 2023年5月1日）
这是考试最大的坑：
Calendar c = Calendar.getInstance();
// 格式：set(年, 月, 日)
// 坑：月份是从 0 开始的！(0是1月，4是5月)
c.set(2023, 4, 1); 

// 转换成 Date 打印查看
Date d = c.getTime();
System.out.println(d);

场景 3：获取今天是星期几
int week = c.get(Calendar.DAY_OF_WEEK);
// 注意：西方规定周日是第 1 天，周一是第 2 天...


```