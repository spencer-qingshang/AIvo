## 8.1 为何使用泛型编程

### 8.1.1 类型参数的好处

- 泛型（Generics）就是在类、接口、方法中引入“类型参数”，让代码在编译期就能检查类型、避免强制类型转换，并且提高复用性。

- 作用：

1. 类型安全：编译期发现类型错误

1. 少写强制类型转换

1. 代码复用：同一份逻辑适配多种类型

```java
// 定义一个泛型类：T 是类型参数
class Box<T> {
    private T value;
    public void set(T value) { this.value = value; }
    public T get() { return value; }
}

public class Main {
    public static void main(String[] args) {
        // 装字符串的盒子
        Box<String> box1 = new Box<>();
        box1.set("hello");
        String s = box1.get();   // 无需强转

        // 装整数的盒子
        Box<Integer> box2 = new Box<>();
        box2.set(123);
        Integer n = box2.get();  // 无需强转

        // 编译期类型安全：下面这行会编译错误
        // box1.set(456); // Error: 期望 String，给了 Integer
    }
}

```

### 8.1.2 谁想成为泛型程序员

## 8.2 定义简单泛型类

```java
// 一个最简单的泛型类：Box<T> 我们做一个“盒子”类，能装任意类型的数据。用 T 代表“类型参数”。
public class Box<T> {
    private T value;

    public Box(T value) {        // 构造函数接收 T 类型
        this.value = value;
    }

    public T get() {             // 返回 T 类型
        return value;
    }

    public void set(T value) {   // 设置 T 类型
        this.value = value;
    }
}
//如何使用它
public class Main {
    public static void main(String[] args) {
        // 1) 创建装字符串的盒子
        Box<String> strBox = new Box<>("Hello");
        String s = strBox.get();           // 不需要强制类型转换
        System.out.println(s);

        // 2) 创建装整数的盒子
        Box<Integer> intBox = new Box<>(123);
        Integer n = intBox.get();
        System.out.println(n);

        // 3) 编译期类型安全：下面这行会编译错误（类型不匹配）
        // strBox.set(456); // Error: 需要 String，却给了 Integer
    }
}
```

[](https://zzy979.github.io/posts/java-note-v1ch08-generic-programming/#82-%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B%E7%B1%BB)

## 8.3 泛型方法

```java
public class Utils {
    // 这是一个泛型方法：在返回类型前声明 <T>
    public static <T> void swap(T[] arr, int i, int j) {
        T tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    // 另一个泛型方法：返回两个值中的较大者（需要上界约束）
    public static <T extends Comparable<T>> T max(T a, T b) {
        return (a.compareTo(b) >= 0) ? a : b;
    }
}


public class Main {
    public static void main(String[] args) {
        String[] s = {"A", "B", "C"};
        Integer[] n = {1, 2, 3};

        // 类型参数一般可由编译器推断，无需显式写 <String> 或 <Integer>
        Utils.swap(s, 0, 2);  // -> ["C", "B", "A"]
        Utils.swap(n, 0, 1);  // -> [2, 1, 3]

        // 带上界的泛型方法
        System.out.println(Utils.max(5, 9));          // 9（自动装箱为 Integer）
        System.out.println(Utils.max("aa", "ab"));    // "ab"
        // 显式指定也可以（通常不需要）
        // Integer m = Utils.<Integer>max(10, 7);
    }
}

```

## 8.4 类型变量的边界

- 含义：在定义泛型时，为类型参数设定上界或下界，限制可用的具体类型。

- 目的：让编译器在编译期进行更强的类型检查，并启用多态调用/安全读写。

```java
需求：写一个方法，能比较两个对象的大小并返回较大者。
限制：要调用 compareTo 方法，就需要保证类型实现了 Comparable 接口，这就是上界。
public class BoundsDemo {
// 上界：T 必须实现 Comparable<T>
public static <T extends Comparable<T>> T maxOfTwo(T a, T b) {
    return (a.compareTo(b) >= 0) ? a : b;
}

public static void main(String[] args) {
    Integer x = 3, y = 5;
    System.out.println(maxOfTwo(x, y)); // 输出 5

    String s1 = "apple", s2 = "banana";
    System.out.println(maxOfTwo(s1, s2)); // 输出 banana
    // String 实现了 Comparable<String>，所以也能用
}

需求：往集合中“安全地”写入某类或其父类的集合。
import java.util.*;

public class LowerBoundDemo {
    public static void addIntegers(List<? super Integer> list) {
        list.add(1); // OK，? super Integer 能接收 Integer 或其子类的实例（这里是 Integer）
        list.add(2);
        // 但从 list 读出元素时，只能当作 Object，因为编译器只知道下界
        Object val = list.get(0);
    }

    public static void main(String[] args) {
        List<Number> nums = new ArrayList<>();
        addIntegers(nums); // OK，Number 是 Integer 的父类
        System.out.println(nums); // [1, 2]
    }
}

```

}[](https://zzy979.github.io/posts/java-note-v1ch08-generic-programming/#84-%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%BE%B9%E7%95%8C)

## 8.5 泛型代码和虚拟机

### 8.5.1 类型擦除

- 类型擦除是 Java 泛型在编译期的实现机制：编译器在编译时检查和利用泛型类型信息（保证类型安全、做方法选择等），但在编译后会把泛型类型参数擦除掉，运行期的字节码里不再保留具体的类型参数。

- 常见影响

- 不能直接创建泛型数组：new T[]、new List<String>[10] 都不允许。

- 不能做带参数的 instanceof：if (x instanceof List<String>) 不允许，只能 instanceof List。

- 方法重载会因擦除导致签名冲突，例如：

- void foo(List<String>) 与 void foo(List<Integer>) 在擦除后都是 void foo(List)，编译报冲突。

- 需要在运行时保留类型信息时，常用“类型令牌”（Class<T>）或 TypeReference：

### 8.5.2 翻译泛型表达式

```java
class Box<T> {
    public T value;           // 泛型字段
    public T get() {          // 泛型返回
        return value;
    }
}

public class ErasureTranslate {
    public static void main(String[] args) {
        Box<String> box = new Box<>();
        box.value = "hi";                     // 写入：编译器在写入前做类型检查
        String s1 = box.value;                // 读取：编译器会在字节码中插入 (String)
        String s2 = box.get();                // 返回：编译器会在字节码中插入 (String)
    }
}


class Box {                  // T 被擦除（无上界则为 Object）
    public Object value;
    public Object get() {
        return value;
    }
}

public class ErasureTranslate {
    public static void main(String[] args) {
        Box box = new Box();
        box.value = "hi";
        String s1 = (String) box.value;       // 编译器插入强转
        String s2 = (String) box.get();       // 编译器插入强转
    }
}

```

### 8.5.3 翻译泛型方法

```java
//示例一：最简单的泛型方法（返回值为类型变量）
class Utils {
    public static <T> T first(T a, T b) {
        return a;
    }
}

public class Demo {
    public static void main(String[] args) {
        String s = Utils.first("A", "B");
        Integer i = Utils.first(1, 2);
    }
}
//概念上的“擦除后翻译”
//类型变量 T 无上界，擦除为 Object。
//方法签名从 <T> T first(T, T) 变成 Object first(Object, Object)。
//在调用处，编译器根据目标类型插入强转。
class Utils {
    // 擦除后
    public static Object first(Object a, Object b) {
        return a;
    }
}

public class Demo {
    public static void main(String[] args) {
        String s = (String) Utils.first("A", "B");   // 编译器插入 (String)
        Integer i = (Integer) Utils.first(1, 2);     // 编译器插入 (Integer)
    }
}


//示例二：带上界的泛型方法
class Mathx {
    public static <T extends Number> T max(T a, T b) {
        return a.doubleValue() >= b.doubleValue() ? a : b;
    }
}
//擦除与翻译
class Mathx {
    // 擦除后
    public static Number max(Number a, Number b) {
        return a.doubleValue() >= b.doubleValue() ? a : b;
    }
}

class Demo2 {
    public static void main(String[] args) {
        Integer r1 = (Integer) Mathx.max(1, 2);        // 插入 (Integer)
        Double  r2 = (Double)  Mathx.max(1.5, 0.5);    // 插入 (Double)
    }
}


//泛型方法返回泛型集合
import java.util.*;

class Collects {
    public static <T> List<T> singleton(T x) {
        List<T> list = new ArrayList<>();
        list.add(x);
        return list;
    }
}

class Demo3 {
    public static void main(String[] args) {
        List<String> ls = Collects.singleton("hi");
        String s = ls.get(0);   // 这里也会在字节码插入 (String)
    }
}

//擦除与调用点的转换
import java.util.*;

class Collects {
    // 擦除后
    public static List singleton(Object x) {
        List list = new ArrayList();
        list.add(x);
        return list;
    }
}

class Demo3 {
    public static void main(String[] args) {
        List ls = Collects.singleton("hi");  // 接口层表现为原始类型
        String s = (String) ls.get(0);       // 使用点插入 (String)
    }
}

//定义：桥方法是 Java 编译器在“类型擦除”导致的方法签名不再匹配时，自动合成的一个 synthetic 方法。它的作用是维持多态与二进制兼容：让子类在擦除后的签名上也能覆盖父类方法。

```

### 8.5.4 调用遗留代码

## 8.6 限制与局限性

### 8.6.1 不能用基本类型替换类型参数

```java
class Pair<T> {
    private T first;
    private T second;

    public Pair(T first, T second) {
        this.first = first;
        this.second = second;
    }
    public T getFirst() { return first; }
    public T getSecond() { return second; }
}


//错误示例
// 编译错误：不允许使用基本类型作为类型参数
Pair<double> p = new Pair<>(1.2, 3.4);


//正确示例<使用包装类型>
Pair<Double> p = new Pair<>(1.2, 3.4); // 1.2 和 3.4 会自动装箱为 Double
Double a = p.getFirst();
Double b = p.getSecond();

// 还可以拆箱成基本类型
double x = p.getFirst(); // 自动拆箱
double y = p.getSecond();

```

### 8.6.2 运行时类型查询只适用于原始类型

```java
import java.util.*;

public class Demo {
    public static void main(String[] args) {
        List<String> a = new ArrayList<>();
        List<Integer> b = new ArrayList<>();

        // 运行时只能判断是否是 List
        if (a instanceof List) { // OK
            System.out.println("a 是 List 的实例");
        }

        // if (a instanceof List<String>) { } // 编译错误：不能用带参数的泛型做 instanceof

        // a 和 b 的运行时 Class 实际相同
        System.out.println(a.getClass() == b.getClass()); // true
    }
}

class Pair<T> { }

public class Demo2 {
    public static void main(String[] args) {
        Pair<String> ps = new Pair<>();
        Pair<Double> pd = new Pair<>();

        // 只能判断是否是 Pair
        System.out.println(ps instanceof Pair); // true
        System.out.println(pd instanceof Pair); // true

        // System.out.println(ps instanceof Pair<String>); // 编译错误

        // 运行时 Class 也相同
        System.out.println(ps.getClass() == pd.getClass()); // true
    }
}
```

### 8.6.3 不能创建泛型类型的数组

```java
import java.util.List;

public class Demo1 {
    public static void main(String[] args) {
        // 不能创建带泛型参数的数组
        // List<String>[] arr = new List<String>[10]; // 编译错误：generic array creation
        // Pair<Integer>[] ps = new Pair<Integer>[5]; // 同样错误
    }

    static class Pair<T> { }
}
//假设 Java 允许 List<String>[]，由于数组是协变的，可以把它赋给 Object[]，然后可以往里塞入 List<Integer>，这会破坏类型安全，但运行时又看不到参数类型，无法阻止。

```

### 8.6.4 变参警告

- 原因：可变参数在运行时会被实现为一个数组。若参数是泛型类型 T...，运行时需要创建 T[]。但“不能创建泛型类型的数组”，因此编译器发出“堆污染/未检查”警告，而不是报错（对这类调用做了放宽）。

- 何时安全：如果方法只“读取”这个 varargs 数组（不把不安全的引用写进数组），就可以用 @SafeVarargs 告诉编译器“这是安全的”，抑制警告。

- 限制：@SafeVarargs 只能用于 static、final 方法或（Java 9 起）private 方法/构造器，因为可被重写的方法可能在子类中变得不安全，注解就失去意义。

- 危险示例：利用 varargs 返回泛型数组，容易让数组的协变特性与泛型擦除冲突，导致运行时类型不安全。

```java
import java.util.*;

public class Demo1 {
    public static <T> void addAll(Collection<T> coll, T... ts) {
        // 这里只把 ts 的元素加入集合，没有往 ts 里写入别的引用
        for (T t : ts) coll.add(t);
    }

    public static void main(String[] args) {
        Collection<Pair<String>> table = new ArrayList<>();
        Pair<String> p1 = new Pair<>("A");
        Pair<String> p2 = new Pair<>("B");

        // 这里会出现“泛型可变参数”的未检查警告（varargs of parameterized type）：
        // 因为 T... 会在运行时成为 T[]，而 T 可能是 Pair<String> 这样的泛型类型
        addAll(table, p1, p2);

        System.out.println(table);
    }

    static class Pair<T> {
        T v;
        Pair(T v) { this.v = v; }
        public String toString() { return "Pair(" + v + ")"; }
    }
}


import java.util.*;

public class Demo2 {
    @SafeVarargs
    public static <T> void addAll(Collection<T> coll, T... ts) {
        // 只读 ts，不向 ts 写入其他类型，因此是安全的
        for (T t : ts) coll.add(t);
    }

    public static void main(String[] args) {
        List<List<String>> lists = new ArrayList<>();
        List<String> a = List.of("x");
        List<String> b = List.of("y");

        // 不再有 varargs 警告
        addAll(lists, a, b);
        System.out.println(lists);
    }
}


public class Demo3 {
    static class Pair<T> { }

    @SafeVarargs
    static <E> E[] array(E... array) {
        // 这里直接把 varargs 数组返回，调用方以为是“E[]”
        return array;
    }

    public static void main(String[] args) {
        Pair<String> p1 = new Pair<>();
        Pair<String> p2 = new Pair<>();
        Pair<String>[] table = array(p1, p2); // 看似得到 Pair<String>[]

        Object[] objArray = table;            // 数组协变，允许
        objArray[0] = new Pair<Integer>();    // 运行时无法检查到泛型参数类型，被写入了“异类”

        // 后续在使用 table[0] 作为 Pair<String> 时，可能在更深处触发 ClassCastException
        System.out.println("混入完成，但这是不安全的做法。");
    }
}

```

### 8.6.5 不能实例化类型变量

- “不能实例化类型变量”指的是：在 Java 泛型中，类型参数 T 在运行时被类型擦除为它的上界（默认是 Object）。因此你在代码里不能写 new T(...) 或 new T[]，因为运行时并不知道 T 的具体类是什么，也就无法创建它的实例或数组。

```java
public class Box<T> {
    // 编译错误：Cannot create a generic array of T
    // T[] arr = new T[10];

    // 编译错误：Cannot instantiate the type T
    // T value = new T();

    // 正确方式 1：通过构造函数注入
    private final T value;
    public Box(T value) { this.value = value; }
    public T get() { return value; }
}

```

### 8.6.6 不能构造泛型数组

- 在 Java 中不能写 new T[] 或 new List<String>[] 这类“泛型数组”的构造，因为泛型有类型擦除，运行时无法知道具体的类型参数，用数组来做运行时类型检查就失效了，所以编译器禁止直接构造。

```java
public class Demo<T> {
    // 编译错误：Cannot create a generic array of T
    // T[] a = new T[10];

    // 编译错误：Cannot create a generic array of List<String>
    // List<String>[] arr = new List<String>[5];
}

import java.util.*;

public class UnsafeDemo {
    public static void main(String[] args) {
        // 假设这句是允许的（实际上会编译错误）
        // List<String>[] stringLists = new List<String>[1];

        // 为了继续演示，我们借道原始类型数组和强转（抑制编译器检查）
        List<String>[] stringLists = (List<String>[]) new List<?>[1]; // 警告：unchecked
        stringLists[0] = new ArrayList<>();

        Object[] objArray = stringLists; // 数组协变成立：List<String>[] 是 Object[] 的子类
        List<Integer> intList = new ArrayList<>();
        intList.add(42);

        // 把 List<Integer> 塞进了“看起来是 List<String>[]”的数组里
        objArray[0] = intList; // 运行时不会报错（数组元素类型是 List，没法区分参数）

        // 后续使用时才炸：我们以为拿到的是 List<String>
        String s = stringLists[0].get(0); // 实际上元素是 Integer，运行到这可能抛 ClassCastException
        System.out.println(s);
    }
}
```

### 8.6.7 泛型类的静态上下文中类型变量无效

- “泛型类的静态上下文中类型变量无效”指的是：类上的类型参数 T 属于“实例级别”的信息，而静态成员属于“类级别”的信息，不依赖任何实例。所以在静态字段、静态方法、静态初始化块中，不能直接使用类的类型参数 T。

- 在没有任何实例存在时，类已经被加载，其静态成员就可以被访问。但此时并没有具体的 T（类型实参）与之绑定。因此编译器禁止在静态上下文里引用类的类型变量。

```java
public class Box<T> {
    // 1) 静态字段不能用 T
    // 编译错误：Cannot make a static reference to the non-static type T
    // private static T cache;

    // 2) 静态方法的签名/局部也不能直接用 T
    // 编译错误：Cannot make a static reference to the non-static type T
    // public static T createDefault() { return null; }

    // 3) 静态初始化块也不能用 T
    // static { T tmp = null; } // 同样报错

    // 正确：在实例成员里可以用 T
    private T value;
    public T get() { return value; }
}


public class Box<T> {
    private T value;

    // 静态泛型方法：声明了一个“自己的”类型参数 U
    public static <U> Box<U> of(U u) {
        Box<U> b = new Box<>();
        b.value = u;
        return b;
    }

    public T get() { return value; }
}

```

### 8.6.8 不能抛出或捕获泛型类的实例

- Java 不允许定义或使用“泛型化的异常类型”。也就是：

- 不能抛出泛型类作为异常；

- 不能捕获带类型参数的异常类型；

- 不能让受检异常类本身是泛型的。

- 原因在于：泛型使用类型擦除实现，而异常在运行时依赖精确的类型信息进行匹配与检查，这两者在异常机制上无法安全地协同。

- 为什么不允许

- 异常匹配发生在运行时，JVM 需要知道确切的异常类来判断是否进入对应的 catch 块。

- Java 泛型在运行时被擦除，T 的具体类型信息不存在。如果允许“泛型异常”，catch 时将无法依据类型参数区分不同变体，可能导致类型安全和匹配语义混乱。

- 受检异常还涉及编译期的 throws 检查，若异常带类型参数，编译器在擦除后难以一致地验证代码的异常声明与处理。

```java
//最小反例 1：泛型异常类定义本身就不允许
// 编译错误：Generic class may not extend 'java.lang.Throwable'
// 或类似提示：The generic class X may not subclass java.lang.Throwable
public class BadException<T> extends Exception { // 受检或非受检都不行
}


//最小反例 2：不能捕获“带类型参数”的异常类型
try {
    // ...
} catch (Exception e) {
    // OK
}

// 假如你有一个泛型类 Box<T>，它不是 Throwable，但演示捕获“泛型化异常类型”的语法问题：
/*
catch (Box<String> e) { // 编译期报错：不能在 catch 中使用参数化类型
}
*/

```

### 8.6.9 可以打破对检查型异常的检查

- Java 的受检异常（checked exceptions）要求在编译期显式声明或捕获。但借助某些语言/库技巧，可以在不改变方法签名的情况下让受检异常“溜”过去，从而绕过编译器的静态检查。这被称为“打破对检查型异常的检查”。

```java
public final class Sneaky {
    @SuppressWarnings("unchecked")
    private static <E extends Throwable> void sneakyThrow0(Throwable t) throws E {
        throw (E) t; // 运行时仍会按原异常类型抛出
    }

    public static void sneakyThrow(Throwable t) {
        Sneaky.<RuntimeException> sneakyThrow0(t);
    }
}

// 使用示例：方法签名不声明 throws，但能抛受检异常
public static void demo() {
    try {
        // 某些代码
        throw new java.io.IOException("checked");
    } catch (Throwable t) {
        Sneaky.sneakyThrow(t); // 编译器以为只会抛 RuntimeException
    }
}

```

### 8.6.10 注意擦除后的冲突

- 泛型类型默认不变（Invariant）

- List<Integer> 不是 List<Number> 的子类型，也不是父类型。

- 数组协变（与泛型不同）

- Number[] 可以接收 Integer[]（不安全，运行时可能抛 ArrayStoreException）。

- 通配符用于控制“读/写”方向：

- ? extends T 协变：可读为 T，不能安全写入（除了 null）

- ? super T 逆变：可安全写入 T 及其子类，读出只能当 Object

- 类型参数的边界

- <T extends Number> 上界约束；<T super X> 在类型参数定义处不存在，只在通配符处存在。

```java
List<Number> a = new ArrayList<Number>();
List<Integer> b = new ArrayList<Integer>();

// 编译错误：不变性
// a = b;

// 如果允许 a = b，则 a.add(3.14) 合法，但 b 实际是 List<Integer>，类型会被破坏。

```

## 8.7 泛型类型的继承规则

## 8.8 通配符类型

### 8.8.1 通配符概念

- 写作 ?，表示“某种未知的类型”。它常与上界 extends、下界 super 组合，用来放宽泛型的适配范围，让方法能同时接受多种具体类型的泛型实参。

- 核心目的：在不失去类型安全的前提下，提高泛型 API 的通用性。

```java
//无界通配符：只能安全地“看”，不能“改类型”
import java.util.*;

public class WildcardDemo1 {
    static int sizeOfAnyList(List<?> list) {
        // 可安全读取结构信息或当 Object 使用
        Object first = list.isEmpty() ? null : list.get(0);
        return list.size();
        // list.add("x"); // 编译错误：不知道 ? 的真实类型，禁止写入（除了 null）
    }
    public static void main(String[] args) {
        System.out.println(sizeOfAnyList(List.of(1,2,3)));     // List<Integer>
        System.out.println(sizeOfAnyList(List.of("a","b")));   // List<String>
    }
}


//上界通配符（生产者）：读为父类，不能写
import java.util.*;

public class WildcardDemo2 {
    static double sumNumbers(List<? extends Number> xs) {
        double s = 0;
        for (Number n : xs) s += n.doubleValue(); // 读：当作 Number 使用
        // xs.add(1); // 编译错误：不能写入（除了 null）
        return s;
    }
    public static void main(String[] args) {
        System.out.println(sumNumbers(List.of(1, 2, 3)));        // List<Integer>
        System.out.println(sumNumbers(List.of(1.5, 2.5, 3.0))); // List<Double>
    }
}

//下界通配符（消费者）：能写 T，读出仅为 Object
import java.util.*;

public class WildcardDemo3 {
    static void addAllIntegers(List<? super Integer> dst, List<Integer> src) {
        for (Integer x : src) dst.add(x); // 安全写 Integer
        Object any = dst.get(0); // 读出类型未知，只能当 Object
    }
    public static void main(String[] args) {
        List<Number> nums = new ArrayList<>();
        addAllIntegers(nums, List.of(1,2,3)); // 接受 List<Number>、List<Object> 等
        System.out.println(nums); // [1, 2, 3]
    }
}

```

### 8.8.2 通配符的超类边界

- 通配符的超类边界写作 ? super T，读作“某个是 T 的父类型（或 T 本身）的未知类型”。

- 作用：把一个泛型参数限制为“接收 T 及其子类作为元素的容器”（消费者场景）。这就是 PECS 中的 Consumer Super。

- 你把一个容器标注为 List<? super Integer>，意思是：这个容器至少能装得下 Integer（以及它的子类），所以你可以安全地往里放 Integer。

- 但容器里原本装的具体类型不确定（可能是 Number、Object 等），因此读出来时只能安全地当作 Object 看待。

```java
import java.util.*;

public class SuperBoundDemo {
    // 把一组 Integer 添加到一个“接收 Integer 的父类型”的容器里
    static void addAllIntegers(List<? super Integer> dst, List<Integer> src) {
        for (Integer x : src) {
            dst.add(x); // 安全：dst 至少是 List<Integer>/List<Number>/List<Object> 之一
        }
        // Integer v = dst.get(0); // 编译错误：读出类型不确定
        Object any = dst.get(0);   // 只能当作 Object 读取
    }

    public static void main(String[] args) {
        List<Number> numbers = new ArrayList<>();
        List<Object> objects = new ArrayList<>();

        addAllIntegers(numbers, List.of(1, 2, 3)); // OK：Number 是 Integer 的超类
        addAllIntegers(objects, List.of(4, 5));    // OK：Object 也是其超类

        System.out.println(numbers); // [1, 2, 3]
        System.out.println(objects); // [4, 5]
    }
}

```

### 8.8.3 无边界通配符

- 表达“任意类型”的容器：List<?> 可以接收 List<String>、List<Integer>、List<Anything>。

- 你可以把元素当作 Object 来读，但不能写入任何具体类型（除 null）。

- 常用于只读工具方法或通用接口签名，增强通用性。

```java
import java.util.*;

public class UnboundedWildcardDemo {
    // 接受任意类型的 List，进行与类型无关的只读操作
    static void printList(List<?> list) {
        System.out.println("size = " + list.size());
        for (Object x : list) {       // 读：当作 Object 处理
            System.out.println(x);
        }
        // list.add("x");             // 编译错误：未知具体类型，禁止写
        // list.add(123);             // 编译错误
        list.add(null);               // 唯一允许写入的是 null
    }

    public static void main(String[] args) {
        printList(List.of(1, 2, 3));          // List<Integer>
        printList(List.of("a", "b", "c"));    // List<String>
        printList(List.of(true, false));      // List<Boolean>
    }
}

```

### 8.8.4 通配符捕获

通配符捕获（Wildcard Capture）是编译器在方法内部把“未知类型 ?”临时“捕获”为一个具体的类型参数，从而允许你在方法内部对这个未知类型进行安全操作的机制。简单说：在方法签名里是 List<?>，进到某个泛型辅助方法后，编译器把它视为 List<T>（T 为编译器推断出来的“被捕获类型”）。

为什么需要捕获

- 直接在 List<?> 上写元素会报错，因为 ? 的真实类型未知。

- 但有些操作在“所有元素类型相同”的前提下是安全的，比如交换两个元素、复制到相同元素类型的另一个容器。这就需要通配符捕获把 ? 变成某个 T。

最小例子：交换列表前两个元素（swap）

- 目标：对任意类型的 List<?> 执行交换。直接在 List<?> 上写会失败，因此用一个带类型参数的辅助方法来“捕获”通配符。

```java
import java.util.*;

public class WildcardCaptureDemo {
    // 对外暴露的 API：接受任意类型的 List
    public static void swapFirstTwo(List<?> list) {
        // 通过辅助方法“捕获”通配符为某个具体类型 T
        swapHelper(list);
    }

    // 辅助方法：引入类型形参 T，以捕获上面 list 的未知类型
    private static <T> void swapHelper(List<T> list) {
        if (list.size() >= 2) {
            T a = list.get(0);
            T b = list.get(1);
            list.set(0, b);
            list.set(1, a);
        }
    }

    public static void main(String[] args) {
        List<Integer> li = new ArrayList<>(List.of(1, 2, 3));
        List<String> ls = new ArrayList<>(List.of("a", "b", "c"));

        swapFirstTwo(li); // OK
        swapFirstTwo(ls); // OK

        System.out.println(li); // [2, 1, 3]
        System.out.println(ls); // [b, a, c]
    }
}

//发生了什么
//swapFirstTwo 的参数类型是 List<?>，无法直接 list.set(...)，因为 ? 未知。
//调用 swapHelper(list) 时，编译器推断一个具体类型 T 来匹配该次调用的 list（例如 T=Integer 或 T=String），从而允许读写为 T。这个推断过程就是“通配符捕获”。
```

## 8.9 反射和泛型

### 8.9.1 泛型Class类

概念

- 在 Java 反射中，Class<T> 表示“运行时类型对象”的泛型形式，T 是该类型所代表的类的实例类型。

- 你可以用 Class<T> 来获得类型信息、创建实例、做类型检查/转换，同时保留一定的编译期类型安全。

- 常见签名如 Class<String>、Class<Integer>、Class<? extends Number>、Class<?> 等。

为什么用泛型

- 比如把 Class 作为参数传给工厂/反射工具时，用 Class<T> 可以让返回值是 T，避免到处强转。

- 还能结合上界通配符来放宽接受范围，如 Class<? extends Number> 接受 Integer.class、Double.class 等。

最小例子：用 Class<T> 构造对象并返回正确类型

```java
import java.lang.reflect.Constructor;

public class ClassGenericDemo {
    // 泛型工厂：传入类对象 Class<T> 和构造参数，返回 T
    public static <T> T newInstance(Class<T> cls, Object... args) {
        try {
            // 根据参数类型匹配构造器（简化：只匹配精确类型）
            Class<?>[] paramTypes = new Class<?>[args.length];
            for (int i = 0; i < args.length; i++) {
                paramTypes[i] = args[i].getClass();
            }
            Constructor<T> ctor = cls.getDeclaredConstructor(paramTypes);
            ctor.setAccessible(true);
            return ctor.newInstance(args);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    static class Point {
        final int x, y;
        public Point(int x, int y) { this.x = x; this.y = y; }
        public String toString() { return "Point(" + x + "," + y + ")"; }
    }

    public static void main(String[] args) {
        // 通过 Class<Point> 创建对象，并得到静态类型为 Point 的返回值
        Point p = newInstance(Point.class, 3, 5);
        System.out.println(p); // Point(3,5)

        // 对比：如果是 Class<?>，返回就只能是 Object，还要强转
        Class<?> any = String.class;
        Object s = newInstance((Class<Object>) any, "hello"); // 需要小心类型
        System.out.println(s);
    }
}

```

### 8.9.2 使用Class<T>参数进行类型匹配

- 指在方法签名中接收 Class<T>，用它来判断/匹配实参的运行时类型，并据此做安全的转换、分派或实例化。

- 价值：避免裸 Object 的强转风险，让编译器通过 T 把返回值、变量等约束到正确类型；同时在运行时用 type.isInstance / type.cast 做校验。

- 常见场景

- 类型安全的工厂/解析器：传入想要的目标类型 Class<T>，返回 T。

- 多分派/策略选择：根据传入的 Class<?> 选择不同处理逻辑。

- 安全强转：用 type.isInstance 与 type.cast 替代 (T) 强转。

```java
import java.util.*;

public class ClassMatchDemo {

    // 根据目标类型进行“类型匹配 + 返回类型推断”
    public static <T> T parse(String s, Class<T> type) {
        Object value;
        if (type == Integer.class) {
            value = Integer.parseInt(s);
        } else if (type == Long.class) {
            value = Long.parseLong(s);
        } else if (type == Boolean.class) {
            value = Boolean.parseBoolean(s);
        } else if (type == Double.class) {
            value = Double.parseDouble(s);
        } else if (type == String.class) {
            value = s;
        } else {
            throw new IllegalArgumentException("Unsupported type: " + type.getName());
        }
        // 使用 Class<T>.cast 保证运行时安全转换
        return type.cast(value);
    }

    public static void main(String[] args) {
        Integer i = parse("42", Integer.class);   // 返回静态类型 Integer
        Boolean b = parse("true", Boolean.class); // 返回静态类型 Boolean
        String  t = parse("hello", String.class); // 返回静态类型 String

        System.out.println(i + ", " + b + ", " + t);
    }
}

```

### 8.9.3 虚拟机中的泛型类型信息

核心概念

- 类型擦除：在 JVM 运行时，大多数泛型参数类型会被擦除为原始类型（如 List<String>、List<Integer> 都变成 List），这叫“类型擦除”。因此普通情况下，JVM并不知道 T 具体是 String 还是 Integer。

- 泛型类型信息的残留：虽然擦除了，但编译器会把“泛型信息”写进字节码的签名与注解里（如方法签名中的 Signature 属性、字段的泛型签名、方法返回类型、局部变量的泛型注解等）。运行时通过反射仍可在“类、字段、方法的声明处”读取这些泛型信息，但“实例对象的运行时类型”通常拿不到具体的 T。

- 能读到/读不到的边界：

- 能读到：类/方法/字段的声明上的泛型参数与实际类型实参（通过反射 API，如 Field#getGenericType、Method#getGenericReturnType、Class#getGenericSuperclass 等）。

- 读不到：运行时的普通对象引用的实际类型实参（如 List<String> 在运行时只剩下 List），除非你自己额外携带类型令牌 Class<T> 或 TypeReference。

```java
import java.lang.reflect.*;
import java.util.List;

class Box {
    // 声明处包含泛型实参：List<String>
    public List<String> names;
}

public class GenericTypeInfoDemo {
    public static void main(String[] args) throws Exception {
        // 1) 从“声明”读取泛型信息
        Field f = Box.class.getField("names");
        Type genericType = f.getGenericType();
        System.out.println("声明处的泛型类型签名: " + genericType);
        // 输出类似：java.util.List<java.lang.String>

        // 2) 运行时对象的类型擦除
        List<String> a = List.of("A", "B");
        List<Integer> b = List.of(1, 2);
        System.out.println(a.getClass() == b.getClass()); // true，同为 java.util.ImmutableCollections$ListN
        // JVM 看它们是同一类，无法从 a 这个对象本身判断“里面是 String 还是 Integer”
    }
}


//进一步例子：类的泛型父类签名
import java.lang.reflect.*;
import java.util.*;

class StringList extends ArrayList<String> { }

public class SuperTypeDemo {
    public static void main(String[] args) {
        Type t = StringList.class.getGenericSuperclass();
        System.out.println(t); // 输出：java.util.ArrayList<java.lang.String>
        // 说明：在“类的声明层级”上，泛型实参 String 被保存在字节码签名中，可通过反射读取。
    }
}

如何在运行时保留并使用“具体类型信息”
类型令牌（Type Token）：把 Class<T> 或更强的 Type 放到 API 参数里。
例：T parse(String s, Class<T> type)，通过传入 Class<T> 告诉运行时需要的 T。
TypeReference/ParameterizedType：用匿名子类捕获参数化类型信息。
import com.fasterxml.jackson.core.type.TypeReference;
import java.lang.reflect.Type;

TypeReference<List<Map<String,Integer>>> ref = new TypeReference<>() {};
Type captured = ref.getType();
System.out.println(captured); // java.util.List<java.util.Map<java.lang.String, java.lang.Integer>>

```

### 8.9.4 类型字面值

关键点

- 形式：Xxx.class

- 类/接口：String.class、Runnable.class

- 原始类型：int.class、boolean.class、void.class

- 数组类型：int[].class、String[][].class

- 原始原生类型的包装类一样可用：Integer.class

- 作用：提供运行时的类型令牌（type token），便于反射或泛型推断。

- 注意：List<String>.class 这种写法是非法的，因为泛型在运行时被擦除；只能用 List.class。若要携带参数化类型，需借助 Type 或 TypeReference。

```java
public static <T> T newInstance(Class<T> type) {
    try {
        return type.getDeclaredConstructor().newInstance();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}

// 调用：把类型字面值当作“类型令牌”传入
StringBuilder sb = newInstance(StringBuilder.class); // 这里的 StringBuilder.class 就是类型字面值


void handle(Class<String> c) { System.out.println("String"); }
void handle(Class<Integer> c) { System.out.println("Integer"); }

// 传入不同的类型字面值，选择不同重载
handle(String.class);   // 输出：String
handle(Integer.class);  // 输出：Integer


System.out.println(int.class);      // 输出：int
System.out.println(void.class);     // 输出：void
System.out.println(int[].class);    // 输出：class [I
System.out.println(String[][].class); // 输出类似：class [[Ljava.lang.String;


import java.lang.reflect.Type;
import com.fasterxml.jackson.core.type.TypeReference;

Type t = new TypeReference<java.util.List<java.util.Map<String, Integer>>>() {}.getType();
System.out.println(t); // java.util.List<java.util.Map<java.lang.String, java.lang.Integer>>


package genericReflection;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

/**
 * A type literal describes a type that can be generic, such as
 * ArrayList<String>.
 */
class TypeLiteral<T> {
    private Type type;

    /**
     * This constructor must be invoked from an anonymous subclass
     * as new TypeLiteral<. . .>(){}.
     */
    public TypeLiteral() {
        Type parentType = getClass().getGenericSuperclass();
        if (parentType instanceof ParameterizedType paramType)
            type = paramType.getActualTypeArguments()[0];
        else
            throw new UnsupportedOperationException("Construct as new TypeLiteral<...>(){}");
    }

    private TypeLiteral(Type type) {
        this.type = type;
    }

    /**
     * Yields a type literal that describes the given type.
     */
    public static TypeLiteral<?> of(Type type) {
        return new TypeLiteral<Object>(type);
    }

    @Override
    public String toString() {
        if (type instanceof Class clazz) return clazz.getName();
        else return type.toString();
    }

    @Override
    public boolean equals(Object otherObject) {
        return otherObject instanceof TypeLiteral otherLiteral
                && type.equals(otherLiteral.type);
    }

    @Override
    public int hashCode() {
        return type.hashCode();
    }
}

/**
 * Formats objects, using rules that associate types with formatting functions.
 */
class Formatter {
    private Map<TypeLiteral<?>, Function<?, String>> rules = new HashMap<>();

    /**
     * Add a formatting rule to this formatter.
     * @param type the type to which this rule applies
     * @param formatterForType the function that formats objects of this type
     */
    public <T> void forType(TypeLiteral<T> type, Function<T, String> formatterForType) {
        rules.put(type, formatterForType);
    }

    /**
     * Formats all fields of an object using the rules of this formatter.
     * @param obj an object
     * @return a string with all field names and formatted values
     */
    public String formatFields(Object obj) throws IllegalAccessException {
        var result = new StringBuilder();
        for (Field f : obj.getClass().getDeclaredFields()) {
            result.append(f.getName());
            result.append("=");
            f.setAccessible(true);
            Function<?, String> formatterForType = rules.get(TypeLiteral.of(f.getGenericType()));
            if (formatterForType != null) {
                // formatterForType has parameter type ?. Nothing can be passed to its apply method.
                // Cast makes the parameter type to Object so we can invoke it.
                @SuppressWarnings("unchecked")
                Function<Object, String> objectFormatter = (Function<Object, String>) formatterForType;
                result.append(objectFormatter.apply(f.get(obj)));
            }
            else
                result.append(f.get(obj).toString());
            result.append("\n");
        }
        return result.toString();
    }
}

class Sample {
    ArrayList<Integer> nums;
    ArrayList<Character> chars;
    ArrayList<String> strings;

    public Sample() {
        nums = new ArrayList<>();
        nums.add(42); nums.add(1729);
        chars = new ArrayList<>();
        chars.add('H'); chars.add('i');
        strings = new ArrayList<>();
        strings.add("Hello"); strings.add("World");
    }
}

public class TypeLiterals {
    private static <T> String join(String separator, ArrayList<T> elements) {
        var result = new StringBuilder();
        for (T e : elements) {
            if (result.length() > 0) result.append(separator);
            result.append(e.toString());
        }
        return result.toString();
    }

    public static void main(String[] args) throws Exception {
        var formatter = new Formatter();
        formatter.forType(new TypeLiteral<ArrayList<Integer>>(){},
                lst -> join(" ", lst));
        formatter.forType(new TypeLiteral<ArrayList<Character>>(){},
                lst -> "\"" + join("", lst) + "\"");
        System.out.println(formatter.formatFields(new Sample()));
    }
}
```