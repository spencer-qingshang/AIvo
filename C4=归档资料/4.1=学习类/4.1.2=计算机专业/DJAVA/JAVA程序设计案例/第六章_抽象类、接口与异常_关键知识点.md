# 第六章：抽象类、接口与异常 - 必备关键知识点

本章是面向对象高级特性的核心，重点在于理解抽象、规范和程序健壮性。

---

## 1. 抽象类 (Abstract Class)

*   **关键字**：`abstract`
*   **概念**：一个**“半成品”**的类，是普通类的超集。它可以有普通类的所有成员（变量、方法、构造器），也可以有**抽象方法**。它是为了被子类继承而存在的。
*   **作用**：
    1.  **代码复用**：将子类共有的代码（属性和已实现的方法）放在抽象父类中。
    2.  **强制规范**：通过抽象方法，强制子类必须实现某些特定的功能。
*   **核心规则 (必记)**：
    *   **不能被实例化**：不能使用 `new` 关键字创建抽象类的对象。
    *   **可以有构造方法**：其构造方法是给子类在初始化时通过 `super()` 调用的。
    *   **不一定要有抽象方法**：一个抽象类里可以一个抽象方法都没有。
    *   有抽象方法的类**必须**被声明为抽象类。

### 1.1 抽象方法 (Abstract Method)

*   **关键字**：`abstract`
*   **特征**：只有方法声明，**没有方法体**（没有 `{}`），直接以分号 `;` 结尾。
*   **示例**：`public abstract void makeSound();`

---

## 2. 接口 (Interface)

*   **关键字**：`interface` (定义接口), `implements` (实现接口)
*   **概念**：一种**纯粹的规范和标准**，比抽象类更彻底。它只描述一个类应该**“能做什么”**，但不关心**“怎么做”**。
*   **作用**：
    1.  **弥补单继承**：一个类可以 `implements` (实现) **多个接口**，从而获得多种“能力”。
    2.  **解耦合**：面向接口编程，调用者不关心具体实现，只关心标准。
    3.  **实现多态**：不同类实现同一接口，可以有不同的行为表现。
*   **核心规则 (必记)**：
    *   **成员变量**：只能是**常量**，默认被 `public static final` 修饰。必须在声明时就赋值。
    *   **成员方法** (JDK 8之前)：只能是**抽象方法**，默认被 `public abstract` 修饰。
    *   **不能被实例化**：不能使用 `new` 创建接口的对象。
    *   **没有构造方法**。
*   **关系**：
    *   一个类可以**实现** (`implements`) 多个接口。
    *   一个接口可以**继承** (`extends`) 多个其他接口。

### 2.1 抽象类 vs 接口 (面试/考试高频)

| 对比项         | 抽象类 (`abstract class`)          | 接口 (`interface`)                  |
| :------------- | :--------------------------------- | :---------------------------------- |
| **关键字**     | `abstract` / `extends`             | `interface` / `implements`          |
| **继承/实现**  | 单继承 (`extends`)                 | 多实现 (`implements`)               |
| **成员变量**   | 可以是普通变量，也可以是常量       | 只能是 `public static final` 常量   |
| **成员方法**   | 可以有抽象方法，也可以有普通方法   | (JDK8前)只能有 `public abstract` 方法 |
| **构造方法**   | 有构造方法                         | 没有构造方法                        |
| **设计理念**   | **“是不是”** (is-a) 关系，强调所属关系 | **“能不能”** (has-a) 关系，强调能力  |

---

## 3. 异常处理 (Exception Handling)

*   **概念**：程序在**运行期间**发生的不正常情况，它会中断程序的正常流程。
*   **作用**：增强程序的**健壮性 (Robustness)**，即使发生错误，程序也能优雅地处理，而不是直接崩溃。
*   **异常体系**：
    *   **`Throwable`** (所有错误和异常的根类)
        *   **`Error`**：严重错误，通常由JVM底层问题导致（如 `OutOfMemoryError`），程序**无法处理**。
        *   **`Exception`**：一般性异常，程序**可以处理**。
            *   **Checked Exception (编译时异常)**：除了`RuntimeException`及其子类。编译器会强制要求你必须处理（`try-catch` 或 `throws`），否则编译不通过。如 `IOException`, `SQLException`。
            *   **Unchecked Exception (运行时异常)**：`RuntimeException` 及其子类。编译器不强制要求处理，但推荐处理。如 `NullPointerException`, `ArithmeticException`, `ArrayIndexOutOfBoundsException`。
*   **处理方式**：
    1.  **`try-catch-finally`**：自己捕获并处理异常。
    2.  **`throws`**：将异常抛给调用者去处理（“甩锅”）。

### 3.1 异常处理关键字 (必记)

*   **`try`**：包裹**可能发生异常**的代码块。
*   **`catch`**：**捕获**并处理指定类型的异常。可以有多个 `catch` 块，捕获顺序必须是**先子类后父类**。
*   **`finally`**：无论是否发生异常，该代码块**永远都会执行**（除非JVM退出）。通常用于**释放资源**（如关闭文件、关闭网络连接）。
*   **`throw`**：
    *   **位置**：用在**方法体内部**。
    *   **作用**：**手动创建并抛出**一个异常对象。
    *   **语法**：`throw new Exception("错误信息");`
*   **`throws`**：
    *   **位置**：用在**方法声明处**（方法名和 `{` 之间）。
    *   **作用**：**声明**该方法**可能抛出**的异常类型，提醒调用者必须处理。
    *   **语法**：`public void myMethod() throws IOException, SQLException { ... }`

---
