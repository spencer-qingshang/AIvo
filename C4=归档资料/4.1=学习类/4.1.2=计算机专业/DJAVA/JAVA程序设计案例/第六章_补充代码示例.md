# 第六章：抽象类、接口与异常 - 补充代码示例

---

### 1. 抽象类 (Abstract Class) 和抽象方法示例

抽象类用于定义一种“模板”，其中一些方法（抽象方法）的具体实现留给子类去完成。

```java
// 1. 定义一个抽象类 Animal
// 它包含一个已实现的方法 sleep() 和一个未实现的抽象方法 makeSound()
abstract class Animal {
    // 普通方法，所有子类都能直接继承使用
    public void sleep() {
        System.out.println("Zzzz... (正在睡觉)");
    }
    
    // 抽象方法，没有方法体。强制子类必须提供自己的实现。
    public abstract void makeSound();
}

// 2. 创建具体子类 Dog，继承 Animal
class Dog extends Animal {
    // 必须重写父类的抽象方法 makeSound()
    @Override
    public void makeSound() {
        System.out.println("汪汪！");
    }
}

// 3. 创建具体子类 Cat，继承 Animal
class Cat extends Animal {
    // 必须重写父类的抽象方法 makeSound()
    @Override
    public void makeSound() {
        System.out.println("喵~");
    }
}

public class AbstractExample {
    public static void main(String[] args) {
        // Animal myAnimal = new Animal(); // 编译错误！抽象类不能被实例化
        
        Animal myDog = new Dog(); // 使用多态，父类引用指向子类对象
        Animal myCat = new Cat();
        
        System.out.print("狗的行为: ");
        myDog.makeSound(); // 调用的是 Dog 类重写后的方法
        myDog.sleep();     // 调用的是从父类继承来的方法
        
        System.out.print("猫的行为: ");
        myCat.makeSound(); // 调用的是 Cat 类重写后的方法
        myCat.sleep();     // 调用的是从父类继承来的方法
    }
}
```

---

### 2. 接口 (Interface) 示例

接口定义了一套纯粹的“能力”标准。一个类可以实现多个接口，从而获得多种能力。

```java
// 1. 定义“会飞的”能力接口
interface Flyable {
    // 接口中的方法默认是 public abstract
    void fly();
}

// 2. 定义“会游泳的”能力接口
interface Swimmable {
    void swim();
}

// 3. Bird 类只实现 Flyable 接口
class Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("鸟在天上扇动翅膀飞。");
    }
}

// 4. Duck 类同时实现 Flyable 和 Swimmable 接口，获得两种能力
class Duck implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("鸭子也能扑腾着飞一会儿。");
    }

    @Override
    public void swim() {
        System.out.println("鸭子在水里熟练地游泳。");
    }
}

public class InterfaceExample {
    public static void main(String[] args) {
        Bird bird = new Bird();
        Duck duck = new Duck();
        
        System.out.println("鸟的能力:");
        bird.fly();
        
        System.out.println("\n鸭子的能力:");
        duck.fly();
        duck.swim();
    }
}
```

---

### 3. 异常处理示例

#### `try-catch-finally` 示例 (捕获处理)

当代码可能出错时，用它来捕获异常，防止程序崩溃。

```java
public class TryCatchFinallyExample {
    public static void main(String[] args) {
        try {
            // 1. try 块：包裹可能发生异常的代码
            System.out.println("准备执行除法...");
            int result = 10 / 0; // 这行会抛出 ArithmeticException
            System.out.println("计算结果: " + result); // 这行代码不会被执行
            
        } catch (ArithmeticException e) {
            // 2. catch 块：如果 try 中发生了指定类型的异常，就在这里捕获
            System.out.println("捕获到异常！错误信息: " + e.getMessage());
            
        } finally {
            // 3. finally 块：无论是否发生异常，这里的代码最终总会执行
            System.out.println("finally 块被执行，程序结束。");
        }
    }
}
```

#### `throws` 和 `throw` 示例 (抛出处理)

当一个方法自己不想处理异常，可以“甩锅”给调用它的地方去处理。

```java
public class ThrowsAndThrowExample {

    // 1. 使用 throws 在方法声明处，警告调用者：我这个方法可能会抛出异常！
    public static void setAge(int age) throws IllegalArgumentException {
        if (age < 0 || age > 150) {
            // 2. 使用 throw 在方法体内部，手动创建并抛出一个异常对象
            throw new IllegalArgumentException("年龄必须在 0 到 150 之间！");
        }
        System.out.println("年龄设置成功: " + age);
    }

    public static void main(String[] args) {
        // 3. 调用者必须处理这个被“甩锅”的异常，否则编译不通过
        try {
            setAge(25);  // 这一次调用是正常的
            setAge(-5); // 这一次调用会抛出异常
        } catch (IllegalArgumentException e) {
            System.out.println("捕获到从 setAge 方法抛出的异常: " + e.getMessage());
        }
        
        System.out.println("程序继续执行...");
    }
}
```
